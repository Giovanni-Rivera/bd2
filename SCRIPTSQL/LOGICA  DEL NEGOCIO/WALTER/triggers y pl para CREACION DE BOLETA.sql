/*PARA FINES DE PRUEBAS VOY A RELACIONAR UNA LIBRETA CON UNA CUENTA*/

/*INSERT INTO LIBRETA VALUES(1,'1-1-64-5',1);*/

/*TIPO_DE CUENTA
1.- ES PARA AHORRO
2.- ES MONETARIA */

/*1.- FUNCION PARA CONSULTAR EL ESTATUS DE UNA CUENTA 
(POR REQUERIMIENTO DEL PROYECTO UNA CUENTA DE AHORRO SOLO SE LE PUEDE DEBITAR CUADO ESTE ACTIVA SINO NO
SE HARA OTRO STORED PROCEDURE O FUNCION PARA DESHABILITAR LA CUENTA Y QUE EL CLIENTE PUEDA DEJAR SU CUENTA A 0*/

CREATE OR REPLACE FUNCTION FUNCT_VERIFICAR_STATUSCUENTA(NUM_CUENTA VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA OBTENER EL RESULTADO DE IR A VER SI EL CLIENTE  ESTÁ ACTIVO*/
CUENTA_ACTIVA NUMBER;
BEGIN
    SELECT COUNT(ID_CUENTA) INTO CUENTA_ACTIVA FROM CUENTA WHERE ID_CUENTA=NUM_CUENTA AND
    ID_ESTATUS=(SELECT ID_ESTATUS_CUENTA FROM ESTATUS_CUENTA WHERE NOMBRE='HABILITADA');
    IF(CUENTA_ACTIVA=1) THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;
    EXCEPTION
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR EN FUNCION VERIFICAR_STATUSCUENTA: CONTACTAR AL DBA' || SQLERRM); 
END FUNCT_VERIFICAR_STATUSCUENTA;



/*2.- COMO CADA VEZ QUE SE DEPOSITE EN SU CUENTA DE AHORRO, 
EL USUARIO DEBE MOSTRAR LA LIBRETA, VAMOS A IR A VER SI EXISTE LA LIBRETA Y SI ESTA ACTIVA*/
CREATE OR REPLACE FUNCTION FUNCT_EXISTE_LIBRETA (NUM_LIBRETA NUMBER)
RETURN NUMBER
IS
EXISTE_LIBRETA NUMBER;
NO_EXISTE_LIBRETA EXCEPTION;
BEGIN
    SELECT COUNT(*) INTO EXISTE_LIBRETA FROM LIBRETA WHERE LIBRETA.ID_LIBRETA=NUM_LIBRETA 
    AND LIBRETA.ID_ESTATUS=(SELECT ID_ESTATUS_LIBRETA FROM ESTATUS_LIBRETA WHERE NOMBRE='HABILITADA');

    IF(EXISTE_LIBRETA=1) THEN

        RETURN 1;
    ELSE
        RETURN 0;
    END IF;

EXCEPTION
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'ERROR EN FUNCION EXISTE_LIBRETA CONTACTE AL DBA'||SQLERRM);

END FUNCT_EXISTE_LIBRETA;
/
/*3 TENGO QUE CREAR UNA FUNCION QUE ME PERMITA SABER SI EXISTE LA LIBRETA QUE ESTÁ ASOCIADA A LA CUENTA*/
/*ESTA FUNCION RECIBE COMO PARAMETRO EL NUMERO DE CUENTA*/
CREATE OR REPLACE FUNCTION OBTENERID_LIBRETA(NUMERO_CUENTA VARCHAR2)
RETURN NUMBER
IS
ID_LIBRETA_FINAL NUMBER(15);
BEGIN
    /*para cada cuenta debe de existir una libreta de ahorro vigente unicamente, lo validamos */
    SELECT ID_LIBRETA INTO ID_LIBRETA_FINAL FROM LIBRETA WHERE LIBRETA.ID_CUENTA=NUMERO_CUENTA
    AND LIBRETA.ID_ESTATUS=(SELECT ID_ESTATUS_LIBRETA FROM ESTATUS_LIBRETA WHERE NOMBRE='HABILITADA');
    IF(ID_LIBRETA_FINAL=0) THEN
        RETURN 0;
    ELSE
        RETURN ID_LIBRETA_FINAL;
    END IF;
END;


/*4*.- vamos a crear un trigger para asignar el numero de boleta y este sea utomático*/
/*VAMOS A CREAR LA SECUENCIA*/
CREATE SEQUENCE SEQ_ID_BOLETA
START WITH 1
INCREMENT BY 1;


/*CREANDO EL TRIGGER PARA QUE SEA AUTOINCREMENTABLE*/
CREATE OR REPLACE TRIGGER BI_BOLETA
BEFORE INSERT ON BOLETA
FOR EACH ROW
BEGIN
    SELECT SEQ_ID_BOLETA.NEXTVAL INTO :NEW.ID_BOLETA FROM DUAL;
END;


/*ESTADOS DE UNA BOLETA

INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('EN_PROCESO');
INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('TERMINADA');
INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('NO_OPERADA');

*/

/*tipos de boleta*/
    /*1.- depositos a cuenta de ahorro*/
    /*2.- depositos a cuenta monetaria*/
    /*3.- retiro a cuenta de ahorro*/
    

/*VAMOS A CREAR UN STORED PROCEDURE PARA CREAR LA BOLETA, SE ASUME QUE
SEGÚN EL MODELO DE SISTEMA BANCARIO ACTUAL, AHORA NO ES NECESARIO LLENAR UNA BOLETA
FÍSICA, SINO QUE EL CAJERO YA SOLO PARAMETRIZA LAS ENTADAS PARA EL REITRO O DEPOSITO*/
CREATE OR REPLACE PROCEDURE PROC_LLENAR_BOLETA(DATOS_BOLETA BOLETA%ROWTYPE)
IS
/*VARIABLE PARA CAPTURAR EL ID DE LA LIBRETA ADEMAS SI EXISTE Y ESTA ACTIVA*/
RECUPERAR_ID_LIBRETA NUMBER;
/*VARIABLE PARA CAPTURAR UN 1 SI LA CUENTA EXISTE Y 0 SINO*/
COMPROBAR_CUENTA NUMBER;
/*VARIABLE PARA LANZAR LA EXCEPCION CUANDO NO EXISTA LA CUENTA*/
NO_EXISTE_CUENTA EXCEPTION;

BEGIN
    /*antes de poder hacer la transaccion, vamos a validar que la cuenta exista Y ESTE ACTIVA*/
    SELECT FUNCT_EXISTE_CUENTA(DATOS_BOLETA.ID_CUENTA) INTO COMPROBAR_CUENTA FROM DUAL;

    /*SI EXISTE LA CUENTA VAMOS A PROSEGUIR CON LA INSERCION DE DATOS EN LA BOLETA, SINO LANZAMOS UNA EXCEPCION*/
    IF(COMPROBAR_CUENTA=1) THEN
        /*EN BASE AL NUMERO DE CUENTA, VAMOS A OBTENER EL ID DE LA LIBRETA A LA QUE ESTÁ ASOCIADO*/
        SELECT OBTENERID_LIBRETA(DATOS_BOLETA.ID_CUENTA) INTO RECUPERAR_ID_LIBRETA FROM DUAL; 
        /*SI EL NUMERO DE LIBRETA ESTA ASOCIADO A LA CUENTA NOS DEVOLVERA SU ID SINO 0 Y SE MANEJA UNA EXCEPION*/
        IF(RECUPERAR_ID_LIBRETA>0) THEN
            /*INSERTAMOS LOS DATOS EN LA BOLETA VAMOS A PONER EN TIPO_ESTADO 1 QUE ESTO QUIERE DECIR QUE ESTA EN PROCESO
            */
        INSERT INTO BOLETA (MONTO,ID_CUENTA,TIPO_BOLETA,ID_ESTATUS,FECHA_OPERACION) 
        VALUES(DATOS_BOLETA.MONTO, DATOS_BOLETA.ID_CUENTA,DATOS_BOLETA.TIPO_BOLETA,1,SYSDATE);
        ELSE 
            RAISE NO_EXISTE_CUENTA;

        END IF;
    ELSE
        RAISE NO_EXISTE_CUENTA;       
    END IF;
    EXCEPTION
    WHEN NO_EXISTE_CUENTA THEN
    DBMS_OUTPUT.PUT_LINE('EL NUMERO DE CUENTA INGRESADO NO EXISTE, VERIFIQUE LOS DATOS');
    WHEN NO_EXISTE_CUENTA THEN
    DBMS_OUTPUT.PUT_LINE('LA LIBRETA ESTÁ INACTIVA O BLOQUEADA O NO ESTÁ ASOCIADA CON LA CUENTA QUE SOLICITA');
    WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERRROR    LLENAR_BOLETA    '||SQLERRM||'CONTACTE AL DBA1');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERRROR    LLENAR_BOLETA    '||SQLERRM||'CONTACTE AL DBA2');
END PROC_LLENAR_BOLETA;
/
/*ESTADOS DE UNA BOLETA

INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('EN_PROCESO');
INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('TERMINADA');
INSERT INTO ESTATUS_BOLETA (NOMBRE) VALUES('NO_OPERADA');

*/

/*tipos de boleta*/
    /*1.- depositos a cuenta de ahorro*/
    /*2.- depositos a cuenta monetaria*/
    /*3.- retiro a cuenta de ahorro*/


/*PROCEDIMIENTO ALMACENADO FINAL PARA VALIDAR QEUE EL TIPO DE BOLETA SEA EL CORRECTO
PARA LA CUENTA SELECCCIONADA, UNA CUENTA DE AHORRO SE LE DEPOSITA Y DEBITAR CON BOLETAS, MIETRAS
QUE EL CASO DE UNA CUENTA MONETARIA UNICAMENTE VAMOS A PERMITIR DEPOSITOS CON BOLETA, RETIROS NO*/

CREATE OR REPLACE PROCEDURE PROC_CREAR_BOLETA(DATOS_BOLETA BOLETA%ROWTYPE)
/*FUNCION QUE NOS DIRAÁ SI EL TIPO DE BOLETA QUE SE ESCOGIÓ POR PARTE DEL CAJERO COINCIDE CON EL TIPO
DE CUENTA, ES DECIR, ANTES QEU SE INSERTEN LOS VALORES EN LA TABLA BOLETA VAMOS A VERIFICAR ESTO*/
/*1-1-64-5' NUMERO DE CUENTA PARA PRUEBAS*/
IS
NUMERO_CUENTA CUENTA.ID_CUENTA%TYPE;
OBTENER_TIPO_CUENTA NUMBER;
OBTENER_TIPO_BOLETA TIPO_BOLETA.ID_TIPO_BOLETA%TYPE;
BEGIN
    SELECT ID_TIPO INTO OBTENER_TIPO_CUENTA FROM CUENTA WHERE CUENTA.ID_CUENTA=DATOS_BOLETA.ID_CUENTA;
    DBMS_OUTPUT.PUT_LINE(OBTENER_TIPO_CUENTA);

    SELECT ID_TIPO_BOLETA INTO OBTENER_TIPO_BOLETA FROM TIPO_BOLETA WHERE ID_TIPO_BOLETA=DATOS_BOLETA.TIPO_BOLETA;
    DBMS_OUTPUT.PUT_LINE(OBTENER_TIPO_BOLETA);

    /*ESTO NOS INDICA SI ES UNA CUENTA DE AHORRO*/
    IF(OBTENER_TIPO_CUENTA=1) THEN
        
        /*SI ESTE IF SE UTILIZA QUIERE DECIR QUE SERÁ UN DEPÓSITO A CUENTA DE AHORRO*/
        IF(OBTENER_TIPO_BOLETA=(1) )THEN

            DBMS_OUTPUT.PUT_LINE('DEPOSITO A CUENTA DE AHORRO');
            PROC_LLENAR_BOLETA(DATOS_BOLETA);    
            ELSIF(OBTENER_TIPO_BOLETA=(3)) THEN
                DBMS_OUTPUT.PUT_LINE('RETIRO A CUENTA DE AHORRO');
                PROC_LLENAR_BOLETA(DATOS_BOLETA);    
            ELSE
            RAISE_APPLICATION_ERROR(-20003,'EL TIPO DE BOLETA QUE LE ESTA ASIGNANDO NO ES EL CORRECTO, RECTIFIQUE');
        END IF;
    
    /*SI ES UNA CUENTA DE AHORRO VAMOS A VERIFICAR 
    POR REGLA DEFINIDA EN EL PROYECTO UNICAMENTE CON BOLETA EN UNA CUENTA
    MONETARIA VAMOS A PODER UNICAMENTE DEPÓSITOS, LOS RETIROS SON CON CHEQUES*/
    ELSIF(OBTENER_TIPO_CUENTA=2) THEN
         /*SI ESTE IF SE UTILIZA QUIERE DECIR QUE SERÁ UN DEPÓSITO A CUENTA MONETARIA*/
        IF(OBTENER_TIPO_BOLETA=(2) )THEN

            DBMS_OUTPUT.PUT_LINE('DEPOSITO A CUENTA DE AHORRO');
            PROC_LLENAR_BOLETA(DATOS_BOLETA);
            /*NO PODEMOS HACER RETIROS DE UNA CUENTA MONETARIA CON UNA BOLETA, SOLO CON CHEQUES*/
            ELSIF(OBTENER_TIPO_BOLETA=(4)) THEN
            RAISE_APPLICATION_ERROR(-20004,'SOLO SE PUEDEN HACER RETIROS DE UNA CUENTA MONETARIA CON CHEQUE');

            ELSE
            RAISE_APPLICATION_ERROR(-20005,'EL TIPO DE BOLETA QUE LE ESTA ASIGNANDO NO ES EL CORRECTO, RECTIFIQUE');
        END IF;
    ELSE
        RAISE_APPLICATION_ERROR(-20006,'NO EXISTE OTRO TIPO DE CUENTA POR EL MOMENTO');
    END IF;

END;


/*BLOQUE ANONIMO PARA CREAR LA BOLETA */

DECLARE
DATOS_BOLETA BOLETA%ROWTYPE;
BEGIN
DATOS_BOLETA.MONTO:=900.78;
DATOS_BOLETA.ID_CUENTA:='1-1-64-5';
DATOS_BOLETA.TIPO_BOLETA:=1;
PROC_CREAR_BOLETA(DATOS_BOLETA);
END;








/* ESTO NOS PUEDE SERVIR PARA QUE SI SE CAMBIA EL ESTATUS DELCLIETE, EN AUTOMÁTICO SE CAMBIE EL ESTADO DE SU CUENTA

SELECT  CL.ID_ESTATUS_CLIENTE FROM CLIENTE CL
INNER JOIN CLIENTE_ASOCIADO_CUENTA CAC
ON CL.ID_CLIENTE_NUMERO=CAC.ID_CLIENTE
INNER JOIN CUENTA CU
ON CAC.ID_CUENTA= CU.ID_CUENTA
WHERE CU.ID_CUENTA='1-1-64-5' AND CAC.ID_CLIENTE=4;

*/

