/*Los tipos de productos y código respectivos son:
1. cuenta ahorro
2. cuenta monetaria
El número de una cuenta, estará dado por los siguientes dígitos (separados por guion):
o tipo de producto
o agencia donde se apertura la cuenta
o correlativo de cuenta por cada tipo de cuenta
o el último digito esta dado aleatoriamente entre 0 y 9.

Ejemplo: Cuentas Ahorro 1 – 123 – 0000001 – 0 
(Cuenta de Ahorro, aperturada en la agencia 123, correlativo 1)

Cuentas Monetarias 2 – 044 – 00000011 – 2 (Cuenta Monetaria, aperturada en la agencia 44, correlativo 11)

Tipos de Cuentas: Ahorro y Monetaria
o Operaciones sobre las cuentas: Retiro y Deposito

vPara aperturar cualquier cuenta, es necesario presentar únicamente el DPI del cliente o la patente de comercio si es una empresa.

*/ 

/*1.- COMO SON 2 CORRELATIVOS DISTINTOS TANTO UNO PARA CUENTA DE CUENTA DE AHORRO
Y OTRO PARA CUENTA MONETARIA*/

/*1.1 CORRELATIVO PARA LA CUENTA DE AHORRO*/
CREATE SEQUENCE SEQ_CORRELATIVO_AHORRO
START WITH 1
INCREMENT BY 1;

/*1.2 CORRELATIVO PARA LA CUENTA MONETARIA*/
CREATE SEQUENCE SEQ_CORRELATIVO_MONETARIA
START WITH 1
INCREMENT BY 1;

/*1.2 CORRELATIVO PARA LA CUENTA DE UN CLIENTE PARA QUE LE PAGUEN*/
CREATE SEQUENCE SEQ_CORRELATIVO_PAGOPLANILLA
START WITH 1
INCREMENT BY 1;


/*2.- VAMOS A CREAR UNA FUNCION QUE NOS DEVUELVA UN NÚMERO
ALEATORIO ENTRE EL 0 Y EL NUEVE, PUES ESTE FORMARÁ PARTE DEL ÚLTIMO DÍGITO DE LA CUENTA*/

CREATE OR REPLACE FUNCTION FUNCT_NUMERO_ALEATORIO
RETURN NUMBER
IS
VARIABLES NUMBER;
BEGIN
   SELECT ROUND(DBMS_RANDOM.VALUE(0,9)) INTO VARIABLES FROM DUAL;
   RETURN VARIABLES;

END;

/*3.- PARA LA CREACIÓN DE CUENTA ES ÚNICAMENTE NECESARIO EL DPI DEL CLIENTE O SI ES UNA EMPRESA
LA PATENTE DE COMERCIO, ADEMÁS, NOSOTROS COMO DBA'S VAMOS A DAR ACCESO ÚNICAMENTE AL USUARIO QUE 
REALICE LA APERTURA DE LA CUENTA ÚNICAMENTE A QUE ESCOJA SI ES DE AHORRO O MONETARIA, EL MONTO A 
DEPOSITAR PARA LA APERTURA (EN EL REQUERIMIENTO DEL PROYECTO NO ESTABLECE UN MÍNIMO O MÁXIMO,
NOSOTROS NO VAMOS A DEFINIR UN MONTO PARA APERTURA DE CUENTA, PERO DEBE SER IGUAL Ò MAYOR A 0
ADEMÁS DEL ID DEL USUARIO DEL SISTEMA QUE ESTÁ CREANDO LA CUENTA, ESTO EL SOFTWARE LO HARÁ POSTERIORMENTE
DEL LADO DEL FRONTEND PARA ENVIAR AL BACKEND LOS DATOS*/

/*3.1 VAMOS A CREAR UNA FUNCIÓN PARA QUE NOS VERIFIQUE SI EL DPI DEL CLIENTE YA ESTÁ REGISTRADO EN EL SISTEMA
ES DECIR, SI PREVIAMENTE YA FUE REGISTRADO COMO CLIENTE VALGA LA REDUNDANCIA NOS DEVOLVERÁ TRUE=1 SI EXISTE Y
FALSE=0 SI NO ADEMÁS SI ESTÁ ACTIVO*/
CREATE OR REPLACE FUNCTION FUNCT_EXISTE_CLIENTE (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
CONTAR_CLIENTE NUMBER;
BEGIN
    SELECT COUNT(C.DPI) INTO CONTAR_CLIENTE FROM CLIENTE C WHERE C.DPI=DPI_CLIENTE
    AND C.ID_ESTATUS_CLIENTE=(SELECT EC.ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE EC WHERE EC.NOMBRE='ACTIVO');
    
    IF(CONTAR_CLIENTE=1) THEN
    RETURN CONTAR_CLIENTE;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UN CLIENTE ASOCIADO CON EL DPI PROPORCIONADO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_EXISTE_CLIENTE;


/*3.2 SE TIENE QUE VALIDAR QUE UN CLIENTE ESTÉ ASOCIADO ÚNICAMENTE  COMO MAXIMO A TRES FIRMAS (CUENTAS)
SE TOMARÁ EN CUENTA TAMBIÉN LA PROPIA, POR LO QUE SON ÚNICAMENTE 2 CUENTAS AJENAS TAMBIÉN QUE SE PUEDEN 
ASOCIAR*/
CREATE OR REPLACE FUNCTION FUNCT_CANTIDAD_FIRMAS_CUENTA (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
CORRELATIVO_CLIENTE NUMBER;
NUM_CLIENTE NUMBER;
TOTAL_FIRMAS NUMBER;
BEGIN
    /*PRIMERO VERIFICAMOS SI EL CLIENTE YA ESTÁ CREADO EN NUESTRA TABLA CON EL MISMO NOMBRE*/
    SELECT COUNT(CL.ID_CLIENTE_NUMERO) INTO NUM_CLIENTE FROM CLIENTE CL WHERE CL.DPI=DPI_CLIENTE;

    /*SI EFECTIVAMENTE EXITE, VAMOS IR A VER A LA TABLA CLIENTE_ASOCIADO_CUENTA A  CUANTAS ESTÁ ASOCIADO 
    EL CLIENTE*/
    IF(NUM_CLIENTE>0) THEN
        /*VAMOS A TRAER EL ID DEL CLIENTE*/
        SELECT CL.ID_CLIENTE_NUMERO INTO CORRELATIVO_CLIENTE FROM CLIENTE CL WHERE CL.DPI=DPI_CLIENTE;
        /*CONTAMOS CUANTAS FIRMAS ESTÀN ASOCIADAS A ESE CLIENTE*/
        SELECT COUNT(CAC.ID_CLIENTE) INTO TOTAL_FIRMAS FROM CLIENTE_ASOCIADO_CUENTA CAC 
        WHERE CORRELATIVO_CLIENTE=CAC.ID_CLIENTE;
        /*DEVOLVEMOS LA CANTIDAD, LA VALIDACIÓN DE VER SI TIENE COMO MÁXIMO 3 FIRMAS ASOCIADAS
        SE HARÁ EN EL STORED PRODEDURE PRINCIPAL DE LA APERTURA DE LA CUENTA*/
        RETURN TOTAL_FIRMAS;
    ELSE
    /*SINO EXISTE UN CLIENTE ASOCIADO, VAMOS A DEVOLVER UN 0 PARA MANEJA LA EXPEPCION EN EL STORED 
    PROCEDURE PRINCIPAL*/
        RETURN 0;
    END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No se puede continuar con la operación, debe de registrar primero al cliente');
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    CONTACTE AL DBA');
END FUNCT_CANTIDAD_FIRMAS_CUENTA;
COMMIT;

CREATE OR REPLACE FUNCTION FUNCT_CREAR_NUMERO_CUENTA(TIPO_CUENTAS NUMBER)
RETURN VARCHAR2
IS
/*VAMOS A CAPTURAR ACÁ EL NUMERO DE CUENTA FINAL QUE SE CREARÁ*/
NUMERO_FINAL VARCHAR2(30);
/*VARIABLE PARA SABER SI ES UN TIPO DE CUENTA MONETARIA O DE AHORRO*/
TIPO_CUENTA_FINAL TIPO_CUENTA.NOMBRE%TYPE;
/*VARIABLE PARA RECUPERAR A QUE AGENCIA PERTENECE EL USUARIO QUE ESTÁ CREANDO LA CUENTA*/
ID_AGENCIA_APERTURA USUARIO.ID_AGENCIA%TYPE;
/*VARIABLE PARA OBTENER DE LA FUNCION EL NUMERO ALEATORIO QUE NECESITAMOS*/
NUMERO_ALEATORIO NUMBER; 
/*VAMOS A IR A BUSCAR EL ID DEL USUARIO QUE ESTA ACTIVO, ESTO PARA SABER DE QUE AGENCIA ESTÁ HACIENDO EL MOVIMIENTO*/
ID_USUARIO_ACTIVO USUARIO.ID_USUARIO%TYPE;
/*PARA CAPTURAR DE LA FUNCION EL NUMERO ALEATORIO*/
NUMERO_RANDOM NUMBER;
/*EXCEPCION SI POR ALGUN MOTIVO (NO DEBIERA DE SUCEDER) QUE EL USUARIO ESTÉ PRETENDIENDO CREAR OTRO TIPO DE CUENTA
(APARTE DE LA MONENTARIA Y DE AHORRO)*/
NO_EXISTE_TIPO_CUENTA EXCEPTION;
/*EXCEPCIÓN PARA DETERMINAR SI UN USUARIO NO ESTÁ ACITVO O NO EXISTE EN LA TABLA USUARIO*/
USUARIO_INEXINAC EXCEPTION;

BEGIN
    /*PRIMERO DEBEMOS SABER DE DONDE SE ORIGINA LA CREACION DE LA CUENTA, ES DECIR DE LA AGENCIA, POR ENDE
    DEBEMOS RECUPERAR EL ID DEL USUARIO  PARA SABERLO*/
    SELECT U.ID_USUARIO INTO ID_USUARIO_ACTIVO FROM USUARIO U WHERE U.NOMBRE_USUARIO=(SELECT USERNAME FROM ALL_USERS WHERE USERNAME=USER)
    AND U.ESTATUS_USUARIO=(SELECT ID_ESTATUS_USUARIO FROM ESTATUS_USUARIO WHERE NOMBRE='ACTIVO');
    /*SI EXISTE EL USUARAIO, ADEMÁS SI ESTÁ ACTIVO */
    IF(ID_USUARIO_ACTIVO>0) THEN
        /*vamos en base al id recuperado del usuario que está haciendo la creación, ir a buscar el id de la agencia*/
        SELECT U.ID_AGENCIA INTO ID_AGENCIA_APERTURA FROM USUARIO U WHERE U.ID_USUARIO=ID_USUARIO_ACTIVO;
        /*LUEGO VAMOS A VERIFICAR SI LA CUENTA A CREAR ES MONETARIA O DE AHORRO, VAMOS A RECUPERAR SEGÚN EL ID SI ES DE AHORRO O MONETARIA*/
        SELECT TP.NOMBRE INTO TIPO_CUENTA_FINAL FROM TIPO_CUENTA TP WHERE TP.ID_TIPO_CUENTA=TIPO_CUENTAS;
        /*ANTES DE CREAR EL NUMERO, VAMOS A CAPTURAR EL NÚMERO ALEATORIO */
        SELECT FUNCT_NUMERO_ALEATORIO INTO NUMERO_RANDOM FROM DUAL;

        /*VALIDAMOS SI ES DE AHORRO O MONETARIA*/
        IF(TIPO_CUENTA_FINAL='DE AHORRO') THEN
           
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_AHORRO.NEXTVAL||'-'||NUMERO_RANDOM;
            
            RETURN NUMERO_FINAL;
        ELSIF(TIPO_CUENTA_FINAL='MONETARIA') THEN
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_MONETARIA.NEXTVAL||'-'||NUMERO_RANDOM;
            RETURN NUMERO_FINAL;
        /*AÚN NO SE HA CREADO, PUES SERÁ PARA LA ENTREGA FINAL, LA OPCIÓN DE CREAR CUENTAS PERO SOLO PARA PAGO DE PLANILLAS
        SE SABE Y SE ENTIENDE QUE ESTAS NO DEBEN GENERAR INTERESES*/
        ELSIF(TIPO_CUENTA_FINAL='PLANILLA') THEN
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_PAGOPLANILLA.NEXTVAL||'-'||NUMERO_RANDOM;
            RETURN NUMERO_FINAL;
        ELSE 
            RAISE NO_EXISTE_TIPO_CUENTA;
        END IF;
    ELSE
        /*EXCEPCION PARA INDICAR QUE EL USUARIO NO EXISTE DENTRO DE LA BASE DE DATOS O ESTÁ INACTIVO*/
        RAISE USUARIO_INEXINAC;
    END IF;
    EXCEPTION 
    WHEN NO_EXISTE_TIPO_CUENTA THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    EL TIPO DE CUENTA ES INCORRECTO');
    WHEN USUARIO_INEXINAC THEN
         DBMS_OUTPUT.PUT_LINE('EL USUARIO CON EL QUE INTENTA CREAR LA CUENTA NO EXISTE O ESTÁ INACTIVO, NOTIFIQUE AL DBA O GERENTE');
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No se puede continuar con la operación, VERIFIQUE EL TIPO DE CUENTA');
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    CONTACTE AL DBA');
    
END FUNCT_CREAR_NUMERO_CUENTA;





/*3.4 FUNCION QUE PERMITE RECUPERAR EL NUMERO DE AGENCIA DEL USUARIO QUE ESTÁ ACTIVO Y HARÁ LA CREACIÓN DE LA CUENTA */
 CREATE OR REPLACE FUNCTION FUNCT_BUSCAR_AGENCIA
 RETURN NUMBER
 IS
 ID_USUARIO_ACTIVO NUMBER;
 ID_AGENCIA_APERTURA NUMBER;
 BEGIN
     SELECT U.ID_USUARIO INTO ID_USUARIO_ACTIVO FROM USUARIO U
      WHERE U.NOMBRE_USUARIO=(SELECT USERNAME FROM ALL_USERS WHERE USERNAME=USER)
        AND U.ESTATUS_USUARIO=(SELECT ID_ESTATUS_USUARIO FROM ESTATUS_USUARIO WHERE NOMBRE='ACTIVO');
    IF(ID_USUARIO_ACTIVO>0) THEN
        /*vamos en base al id recuperado del usuario que está haciendo la creación, ir a buscar el id de la agencia*/
        SELECT U.ID_AGENCIA INTO ID_AGENCIA_APERTURA FROM USUARIO U WHERE U.ID_USUARIO=ID_USUARIO_ACTIVO;
         RETURN ID_AGENCIA_APERTURA;
    END IF;
   
EXCEPTION
WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('el usuario con que está intentando hacer la operación se encuentra deshabilitado');
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:   '||SQLERRM);
 END FUNCT_BUSCAR_AGENCIA;
 
 
 /*3.5 FUNCIÒN PARA OBTTENER EL ID DEL CLIENTE PARA ASOCIAR DE UNA VEZ LA CUENTA QUE SE CREARÀ CON EL CLIENTE*/
CREATE OR REPLACE FUNCTION FUNCT_OBTENERID_CLIENTE (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
ID_CLIENTE NUMBER;
BEGIN
    SELECT C.ID_CLIENTE_NUMERO INTO ID_CLIENTE FROM CLIENTE C WHERE C.DPI=DPI_CLIENTE
    AND C.ID_ESTATUS_CLIENTE=(SELECT EC.ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE EC WHERE EC.NOMBRE='ACTIVO');
    
    IF(ID_CLIENTE>0) THEN
    RETURN ID_CLIENTE;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UN CLIENTE ASOCIADO CON EL DPI PROPORCIONADO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_OBTENERID_CLIENTE;



/* 3.6 stored PROCEDURE para la apertura de cuenta de un cliente*/

CREATE OR REPLACE PROCEDURE PROC_APERTURA_CUENTA_CLIENTE(DPI_CLIENTE VARCHAR2, TIPO_CUENTAS NUMBER)
IS
/*VARIABLE PARA CAPTURAR EL NUMERO DE CUENTA A CREAR*/
NUMERO_CUENTA VARCHAR2(30);
/*VARIABLE PARA VALIDAR QUE EL CLIENTE ESTÉ PREVIAMENTE CREADO EN LA TABLA CLIENTE*/
EXISTE_CLIENTE NUMBER;
/*VARIABLE PARA SABER SI EL CLIENTE TIENE ASOCIADA ALGUNA CUENTA*/
TIENE_FIRMA NUMBER;
/*SINO EXISTE VAMOS A LEVANTAR UNA EXCEPCION PROPIA*/
NO_EXISTE_CLIENTE EXCEPTION;
/*SI EL CLIENTE YA TIENE UN CUENTA ASOCIADA ES DECIR, QUE ES UNA PROPIA, SE DEBE IMPEDIR
QUE TENGA 2 CUENTAS DEL MISMO TIPO (MONETARIAS Y DE AHORRO)*/
YA_TIENE_CUENTA EXCEPTION;
/*VARIABLE PARA CAPTURA EL NUMERO DE AGENCIA DEL USUARIO QUE VA A CREAR LA CUENTA*/
NUMERO_AGENCIA NUMBER;
/*VARIABLE PARA LUEGO OBTENER EL ID DEL CLIENTE Y ASOCIARLO A LA CUENTA* QUE SE ESTÀ APERTURANDO*/
OBTENER_ID_CLIENTE NUMBER;
BEGIN
    /*USAMOS NUESTRA FUNCION PARA VALIDAR SI EXISTE EL CLIENTE, MANDAMOS COMO PARAMETRO EL DPI*/
    SELECT FUNCT_EXISTE_CLIENTE(DPI_CLIENTE) INTO EXISTE_CLIENTE FROM DUAL;
    DBMS_OUTPUT.PUT_LINE(EXISTE_CLIENTE ||'PROC_APERTURA_CUENTA_CLIENTE');
    /*SOLO DEBE EXISTIR UN CLIENTE POR CADA DPI (RESTRICCION A NIVEL DE COLUMNA CON LA CLÁUSULA
    UNIQUE EN EL CAMPO DEL DPI DE LA TABLA CLIENTE)*/
    IF(EXISTE_CLIENTE=1) THEN
        /*VAMOS A VER SI EL CLIENTE TIENE ASOCIADA ALGUNA CUENTA,
        POR REGLA DEL NEGOCIO PROPIA, NOSOTROS VAMOS A DEFINIR QUE PARA QUE SE LE PUEDA
        ASOCIAR UNA CUENTA, POR LO MENOS ESTE YA TIENE QUE TENER UNA PROPIA*/
        /*EN ESTA VARIABLE VAMOS A CAPTURAR UN NUMERO, SI DEVUELVE  QUIERE DECIR QUE NO TIENE
        NINGUNA CUENTA ASOCIADA Y POR ENDE SE PUEDE CREAR*/
        SELECT FUNCT_CANTIDAD_FIRMAS_CUENTA(DPI_CLIENTE) INTO TIENE_FIRMA FROM DUAL;
        DBMS_OUTPUT.PUT_LINE(TIENE_FIRMA||'TODO BIEN 2');
        /*SINO TIENE UNA CUENTA ASOCIADA QUIERE DECIR QUE LE DEMOS CREAR UNA*/
        IF(TIENE_FIRMA=0) THEN
            /*al ya validar lo anterior, podemos proceder a crear la cuenta del cliente, pero antes
            de todo eso vamos a invocar a nuestra función que nos permita crear el id de la cuenta según lo estipulado
            en el proyecto*/
            SELECT FUNCT_CREAR_NUMERO_CUENTA(TIPO_CUENTAS) INTO NUMERO_CUENTA FROM DUAL;
            DBMS_OUTPUT.PUT_LINE(NUMERO_CUENTA||'TODO BIEN 3');
            /*VAMOS A ABSTRAER EL NUMERO DEL USUARIO QUE ESTÁ ACTIVO HACIENDO LA INSERCIÓN DE LA CUENTA*/
            SELECT FUNCT_BUSCAR_AGENCIA INTO NUMERO_AGENCIA FROM USUARIO;
            DBMS_OUTPUT.PUT_LINE(NUMERO_AGENCIA||'TODO BIEN 4');
            /*CUANDO SE CREA UNA CUENTA EL SALDO DEBE DE ESTAR EN 0 TANTO DEL SALDO EN RESERVA COMO EL DEL MONTO DISPONIBLE*/
            INSERT INTO CUENTA (ID_CUENTA,SALDO_EN_RESERVA, MONTO_DISPONIBLE, FECHA_CREACION, ID_ESTATUS, ID_TIPO, ID_AGENCIA_APERTURA)
            VALUES(NUMERO_CUENTA,0,0,SYSDATE,1,TIPO_CUENTAS,NUMERO_AGENCIA);

            /*YA CON LAS VALIDACIONES ANTERIORES NO ES NECEARIO MANEJAR ALGUNA EXCEPCIÒN PUES PREVIAMENTE GARANTIZAMOS QUE EL
            CLIENTE DEBE EXITIR PARA APERTURAR LA CUENTA*/
            SELECT FUNCT_OBTENERID_CLIENTE(DPI_CLIENTE) INTO OBTENER_ID_CLIENTE FROM DUAL;

            /*INSERTAMOS LOS VALORES EN LA TABLA CLIENTE_ASOCIADO_CUENTA PARA ASOCIAR EL CLIENTE CON LA CUENTA RECIÈN CREADA*/
            INSERT INTO CLIENTE_ASOCIADO_CUENTA (ID_CLIENTE, ID_CUENTA,ID_EMPRESA) VALUES(OBTENER_ID_CLIENTE,NUMERO_CUENTA,'');
        ELSE
            RAISE YA_TIENE_CUENTA;
        END IF;
    ELSE
        RAISE NO_EXISTE_CLIENTE;
    END IF;
EXCEPTION
    WHEN YA_TIENE_CUENTA THEN
     DBMS_OUTPUT.PUT_LINE(' EL USUARIO YA TIENE UNA CUENTA, CONSULTE EN EL SISTEMA');
    WHEN NO_EXISTE_CLIENTE THEN
    DBMS_OUTPUT.PUT_LINE('NO EXISTE EL DPI DEL CLIENTE, FAVOR DE REVISAR QUE ESTÉ CORRECTO O QUE YA SE LE HAYA CREADO');
    WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(' FAVOR DE REVISAR LOS DATOS INGRESADOS, PUES NO ESTÁN REGISTRADOS (CLIENTE)');
    WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA 1 ');
    WHEN OTHERS THEN
     DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA 2 ');
    
END PROC_APERTURA_CUENTA_CLIENTE;



/*---------------------------------------------------------------------------------------------------------------*/
/*CREAACION DE UNA CUENTA TIPO EMPRESA, VAMOS A USAR ALGUNAS DE LAS FUNCIONES ANTERIORES, TAL ES EL CASO
DE LA QUE CREA EL NUMERO DE CUENTA Y VAMOS A GREGAR LAS SIGUIENTES*/


/*3.7 VAMOS A CREAR UNA FUNCIÓN PARA QUE NOS VERIFIQUE SI EL DPI DEL REPRESENTANTE LEGAL YA ESTÁ REGISTRADO EN EL SISTEMA
ES DECIR, SI PREVIAMENTE YA FUE REGISTRADO COMO CLIENTE VALGA LA REDUNDANCIA NOS DEVOLVERÁ TRUE=1 SI EXISTE Y
FALSE=0 SI NO ADEMÁS SI ESTÁ ACTIVO*/

CREATE OR REPLACE FUNCTION FUNCT_EXISTE_PATENTE (DPI_ASOCIADO VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
CONTAR_CLIENTE NUMBER;
BEGIN
    /*VOY A VER SI EL REPRESENTANTE LEGAL ESTÀ ACTIVO*/
    SELECT COUNT(C.DPI) INTO CONTAR_CLIENTE FROM CLIENTE C
    INNER JOIN EMPRESA EMP ON EMP.ID_REPRESENTANTE_LEGAL=C.ID_CLIENTE_NUMERO
     WHERE C.DPI=DPI_ASOCIADO AND C.ID_ESTATUS_CLIENTE=
     (SELECT EC.ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE EC WHERE EC.NOMBRE='ACTIVO');
    
    IF(CONTAR_CLIENTE>0) THEN
    RETURN CONTAR_CLIENTE;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UN CLIENTE ASOCIADO CON EL DPI PROPORCIONADO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_EXISTE_PATENTE;



/*3.8 SE TIENE QUE VALIDAR QUE UNA EMPRESA ESTÉ ASOCIADO ÚNICAMENTE  COMO MAXIMO A TRES FIRMAS (CUENTAS)
SE TOMARÁ EN CUENTA TAMBIÉN LA PROPIA, POR LO QUE SON ÚNICAMENTE 2 CUENTAS AJENAS TAMBIÉN QUE SE PUEDEN 
ASOCIAR*/

CREATE OR REPLACE FUNCTION FUNCT_CANFIRMAS_CUENTEMPRESA (NUMERO_PATENTE_COMERCIO VARCHAR2)
RETURN NUMBER
IS
CORRELATIVO_EMPRESA NUMBER;
NUM_PATENTE NUMBER;
TOTAL_FIRMAS NUMBER;
BEGIN
    /*PRIMERO VERIFICAMOS SI LA EMPRESA YA ESTÁ CREADA EN NUESTRA TABLA EMPRESA  VALGA LA REDUNDANCIA*/
    SELECT COUNT(EMP.NO_PATENTE) INTO NUM_PATENTE FROM EMPRESA EMP WHERE EMP.NO_PATENTE=NUMERO_PATENTE_COMERCIO;
    DBMS_OUTPUT.PUT_LINE(NUMERO_PATENTE_COMERCIO||'VALOR DEL NUMERO DE PATENTE');
    /*SI EFECTIVAMENTE EXITE, VAMOS IR A VER A LA TABLA CLIENTE_ASOCIADO_CUENTA A  CUANTAS ESTÁ ASOCIADA 
    LA EMPRESA*/
    DBMS_OUTPUT.PUT_LINE(NUM_PATENTE||'VALOR DEL NUEMRO DE PATENTE FUNCION FIRMAS CUENTA EMPRESA');
    IF(NUM_PATENTE=1) THEN
        /*VAMOS A TRAER EL ID DEL CLIENTE*/
        SELECT EMP.ID_EMPRESA INTO CORRELATIVO_EMPRESA FROM EMPRESA EMP WHERE EMP.NO_PATENTE=NUMERO_PATENTE_COMERCIO;
        /*CONTAMOS CUANTAS FIRMAS ESTÀN ASOCIADAS A ESE CLIENTE*/
        SELECT COUNT(CAC.ID_EMPRESA) INTO TOTAL_FIRMAS FROM CLIENTE_ASOCIADO_CUENTA CAC 
        WHERE CORRELATIVO_EMPRESA=CAC.ID_EMPRESA;
        /*DEVOLVEMOS LA CANTIDAD, LA VALIDACIÓN DE VER SI TIENE COMO MÁXIMO 3 FIRMAS ASOCIADAS
        SE HARÁ EN EL STORED PRODEDURE PRINCIPAL DE LA APERTURA DE LA CUENTA*/
        RETURN TOTAL_FIRMAS;
    ELSE
    /*SINO EXISTE UN CLIENTE ASOCIADO, VAMOS A DEVOLVER UN -1 PARA MANEJA LA EXPEPCION EN EL STORED 
    PROCEDURE PRINCIPAL*/
        RETURN 0;
    END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No se puede continuar con la operación, debe de registrar primero A LA EMPRESA');
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    CONTACTE AL DBA');
END FUNCT_CANFIRMAS_CUENTEMPRESA;

COMMIT;


 /*3.9 FUNCIÒN PARA OBTTENER EL ID DE LA EMPRESA PARA ASOCIAR DE UNA VEZ LA CUENTA QUE SE CREARÀ CON LA EMPRESA Y EL REPRESENTANTE LEGAL*/
CREATE OR REPLACE FUNCTION FUNCT_OBTENERID_EMPRESA (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
ID_CLIENTE NUMBER;
ID_EMPRESA_E NUMBER;
BEGIN
    SELECT FUNCT_OBTENERID_CLIENTE(DPI_CLIENTE) INTO ID_CLIENTE FROM DUAL;
    SELECT ID_EMPRESA INTO ID_EMPRESA_E FROM EMPRESA WHERE EMPRESA.ID_REPRESENTANTE_LEGAL=ID_CLIENTE;  

    IF(ID_EMPRESA_E>0) THEN
    RETURN ID_EMPRESA_E;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UN CLIENTE ASOCIADO CON EL DPI PROPORCIONADO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_OBTENERID_EMPRESA;



/*3.10*/
/*STORED PROCEDURE PARA LA APERTURA DE UNA CUENTA PARA UNA EMPRESA*/   
CREATE OR REPLACE PROCEDURE PROC_APERTCUENTA_EMPRESA(NUMERO_PATENTE VARCHAR2, DPI_ASOCIADO VARCHAR2, TIPO_CUENTAS NUMBER)
IS
/*VARIABLE PARA CAPTURAR EL NUMERO DE CUENTA A CREAR*/
NUMERO_CUENTA VARCHAR2(30);
/*VARIABLE PARA VALIDAR QUE EL CLIENTE ASOCIADO ESTÉ PREVIAMENTE CREADO EN LA TABLA CLIENTE*/
EXISTE_ASOCIADO NUMBER;
/*VARIABLE PARA SABER SI LA EMPRESA TIENE ASOCIADA ALGUNA CUENTA*/
TIENE_FIRMA NUMBER;
/*SINO EXISTE VAMOS A LEVANTAR UNA EXCEPCION PROPIA*/
NO_EXISTE_ASOCIADO EXCEPTION;
/*SI EL CLIENTE YA TIENE UN CUENTA ASOCIADA ES DECIR, QUE ES UNA PROPIA, SE DEBE IMPEDIR
QUE TENGA 2 CUENTAS DEL MISMO TIPO (MONETARIAS Y DE AHORRO)*/
YA_TIENE_CUENTA EXCEPTION;
/*VARIABLE PARA CAPTURA EL NUMERO DE AGENCIA DEL USUARIO QUE VA A CREAR LA CUENTA*/
NUMERO_AGENCIA NUMBER;
/*variable para capturar el del cliente que es el representante legal */
OBTENER_ID_CLIENTE NUMBER;
/*VARIABLE PARA OBTENER EL ID DE LA EMPRESA QUE SERÁ ASOCIADA A LA CUENTA*/
OBTENER_ID_EMPRESA NUMBER;

BEGIN
    /*VAMOS A VER SI EXISTE LA PATENTE*/
    SELECT FUNCT_EXISTE_PATENTE(DPI_ASOCIADO) INTO EXISTE_ASOCIADO FROM DUAL;
    DBMS_OUTPUT.PUT_LINE(EXISTE_ASOCIADO||'TOTAL DE ASOCIADOS');
    /*SOLO DEBE EXISTIR UN CLIENTE POR CADA DPI (RESTRICCION A NIVEL DE COLUMNA CON LA CLÁUSULA
    UNIQUE EN EL CAMPO DEL DPI DE LA TABLA CLIENTE)*/
    IF(EXISTE_ASOCIADO=1) THEN
        /*VAMOS A VER SI LA EMPRESA TIENE ASOCIADA ALGUNA CUENTA,
        POR REGLA DEL NEGOCIO PROPIA, NOSOTROS VAMOS A DEFINIR QUE PARA QUE SE LE PUEDA
        ASOCIAR UNA CUENTA, POR LO MENOS ESTE YA TIENE QUE TENER UNA PROPIA*/
        /*EN ESTA VARIABLE VAMOS A CAPTURAR UN NUMERO, SI DEVUELVE 0 QUIERE DECIR QUE NO TIENE
        NINGUNA CUENTA ASOCIADA Y POR ENDE SE PUEDE CREAR*/
        SELECT FUNCT_CANFIRMAS_CUENTEMPRESA(NUMERO_PATENTE) INTO TIENE_FIRMA FROM DUAL;
        DBMS_OUTPUT.PUT_LINE(TIENE_FIRMA||'TOTAL DE FIRMAS ASOCIADAS');
        /*SINO TIENE UNA CUENTA ASOCIADA QUIERE DECIR QUE LE DEMOS CREAR UNA*/
        IF(TIENE_FIRMA=0) THEN
            /*al ya validar lo anterior, podemos proceder a crear la cuenta del cliente, pero antes
            de todo eso vamos a invocar a nuestra función que nos permita crear el id de la cuenta según lo estipulado
            en el proyecto*/
            SELECT FUNCT_CREAR_NUMERO_CUENTA(TIPO_CUENTAS) INTO NUMERO_CUENTA FROM DUAL;
            /*VAMOS A ABSTRAER EL NUMERO DEL USUARIO QUE ESTÁ ACTIVO HACIENDO LA INSERCIÓN DE LA CUENTA*/
            SELECT FUNCT_BUSCAR_AGENCIA INTO NUMERO_AGENCIA FROM USUARIO;
                /*CUANDO SE CREA UNA CUENTA EL SALDO DEBE DE ESTAR EN 0 TANTO DEL SALDO EN RESERVA COMO EL DEL MONTO DISPONIBLE*/
            INSERT INTO CUENTA (ID_CUENTA,SALDO_EN_RESERVA, MONTO_DISPONIBLE, FECHA_CREACION, ID_ESTATUS, ID_TIPO, ID_AGENCIA_APERTURA)
            VALUES(NUMERO_CUENTA,0,0,SYSDATE,1,TIPO_CUENTAS,NUMERO_AGENCIA);
             /*YA CON LAS VALIDACIONES ANTERIORES NO ES NECEARIO MANEJAR ALGUNA EXCEPCIÒN PUES PREVIAMENTE GARANTIZAMOS QUE EL
            CLIENTE DEBE EXITIR PARA APERTURAR LA CUENTA QUIZÁ ESTO SE PUDO CONVERTIR EN UNA SOLA FUNCION,
            PERO POR FALTA DE TIEMPO AL ESTAR REALIZANDO PRUEBAS NO SE DEPURÓ, PERO CUMPLE CON EL REQUERIMIENTO DEL PROYECTO*/
            SELECT FUNCT_OBTENERID_CLIENTE(DPI_ASOCIADO) INTO OBTENER_ID_CLIENTE FROM DUAL;
            /*variable para capturar el del cliente que es el representante legal */
            SELECT FUNCT_OBTENERID_EMPRESA(DPI_ASOCIADO) INTO OBTENER_ID_EMPRESA FROM DUAL;
            /*INSERTAMOS LOS VALORES EN LA TABLA CLIENTE_ASOCIADO_CUENTA PARA ASOCIAR EL CLIENTE CON LA CUENTA RECIÈN CREADA*/
            INSERT INTO CLIENTE_ASOCIADO_CUENTA (ID_CLIENTE, ID_CUENTA,ID_EMPRESA) VALUES(OBTENER_ID_CLIENTE,NUMERO_CUENTA,OBTENER_ID_EMPRESA);
        ELSE
            RAISE YA_TIENE_CUENTA;
        END IF;
    ELSE
        RAISE NO_EXISTE_ASOCIADO;
    END IF;
EXCEPTION
    WHEN YA_TIENE_CUENTA THEN
     DBMS_OUTPUT.PUT_LINE(' EL USUARIO YA TIENE UNA CUENTA, CONSULTE EN EL SISTEMA');
    WHEN NO_EXISTE_ASOCIADO THEN
    DBMS_OUTPUT.PUT_LINE('EL DPI DEL CLIENTE PRINCIPAL ASOCIADO NO ES CORRECTO, EL DEBE APERTURAR LA EMPRESA');
    WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(' FAVOR DE REVISAR LOS DATOS INGRESADOS, PUES NO ESTÁN REGISTRADOS (CLIENTE)');
    WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA 3');
    WHEN OTHERS THEN
     DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA 4');
    
END PROC_APERTCUENTA_EMPRESA;




/*3.11 COMO OPCIÓN FINAL ES LA USAR ESTE STORED PROCEDURE PARA QUE EL USUARIO SOLO TENGA ACCESO A ESTE OBJECTO DE
LA BASE DE DATOS Y EN CONSECUENCIA TENER UN GRADO MAS ALTO DE SEGURIDAD./
/*NO_PATENTE ES EL CAMPO PARA SABER SI UNA EMPRESA YA ESTÀ REGISTRADA, */
CREATE OR REPLACE PROCEDURE PROC_CREAR_CUENTA(TIPO_CUENTA NUMBER, DPI_CLIENTE VARCHAR2, NO_PATENTE VARCHAR2)
IS
/*UNA SIMPPLE VARIABLE PARA DEFINIR QUE A ALGUN CAMPO QUE MANDA COMO PARAMETRO
LA PERSONA QUE CREA LA CUENTA LE HACE FALTA ALGÚN DATO*/
HACE_FALTA_DATO EXCEPTION;
BEGIN
    IF(DPI_CLIENTE IS NOT NULL AND NO_PATENTE IS NOT NULL) THEN
         PROC_APERTCUENTA_EMPRESA(NO_PATENTE, DPI_CLIENTE, TIPO_CUENTA);

    ELSIF (DPI_CLIENTE IS NOT NULL AND NO_PATENTE IS  NULL) THEN
         PROC_APERTURA_CUENTA_CLIENTE(DPI_CLIENTE, TIPO_CUENTA);
    ELSE 
        RAISE HACE_FALTA_DATO;
    END IF;
EXCEPTION
WHEN HACE_FALTA_DATO THEN
    RAISE_APPLICATION_ERROR(-20002,'LE hace falta un dato para crear la cuenta, ya bien sea el dpi, el tipo de cuenta o Si crea
    una cuenta para empresa, le puede hacer falta el numero de patente, revise');
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'ERROR :    '|| SQLERRM ||'   CONTACTE AL DBA');
END PROC_CREAR_CUENTA;






/*---------------------------------------------------------------------------------------------------------------------*/
                                        /*ASOCIACION DE UNA CUENTA */
/*---------------------------------------------------------------------------------------------------------------------*/
/*VAMOS A CREAR UNA FUNCION QUE NOS DIGA SI EL NUMERO DE CUENTA EXISTE*/
CREATE OR REPLACE FUNCTION FUNCT_EXISTE_CUENTA(NUMERO_CUENTA VARCHAR2)
RETURN NUMBER
IS
CUENTA_NUMERO NUMBER;
BEGIN
    SELECT COUNT(ID_CUENTA) INTO CUENTA_NUMERO FROM CUENTA WHERE CUENTA.ID_CUENTA=NUMERO_CUENTA;
    IF(CUENTA_NUMERO>0) THEN
        RETURN 1;

    ELSE
        RETURN 0;
    END IF; 
RETURN 1;
END;


/*ESTA FUNCION NOS VA A PERMITIR VER SI EXISTE UNA EMPRESA CON EL NUMERO DE PATENTE PROPORCIONADO, SINO LE VAMOS AA INDICAR AL USUARIO*/
CREATE OR REPLACE FUNCTION FUNCT_ASOCIAR_PATENTE (NUMERO_PATENTE VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
CONTAR_PATENTE NUMBER;
BEGIN
    /*VOY A VER SI LA EMPRESA ESTA ACITVA*/
    SELECT COUNT(NO_PATENTE) INTO CONTAR_PATENTE FROM EMPRESA WHERE NO_PATENTE=NUMERO_PATENTE AND ID_ESTATUS=
    (SELECT ID_ESTATUS_EMPRESA FROM ESTATUS_EMPRESA WHERE NOMBRE='ACTIVA');

    /*SI LA EMPRESA ESTÁ ACTIVA Y EL NUMERO DE PATENTE ES CORRECTO RETRONAMOS 1*/
    IF(CONTAR_PATENTE>0) THEN
    RETURN 1;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UNA EMPRESA CON EL NUMERO DE PATENTE PROPROCIONADO, PIDA A SERVICIO AL CLIENTE QUE LE CREE A LA EMPRESA SU PERFIL DENTRO DEL BANCO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_ASOCIAR_PATENTE;



/*vamos a hacer una funcioncita para que nos devuelva el id de la empresa que tiene la patente*/
CREATE OR REPLACE FUNCTION DEVOLVER_ID_EMPRESA(NUMERO_PATENTE VARCHAR2)
RETURN NUMBER
IS
ID_EMPRESA_NUMERO NUMBER;
BEGIN
    SELECT ID_EMPRESA INTO ID_EMPRESA_NUMERO FROM EMPRESA WHERE EMPRESA.NO_PATENTE=NUMERO_PATENTE;
    RETURN ID_EMPRESA_NUMERO;
END DEVOLVER_ID_EMPRESA;
/



//*vamos a crear un stored procedure para validar que una cuenta solo puede tener asociada como máximo 3 firmas
(la del propietario y la de otros 2 clientes aparte*/

CREATE OR REPLACE PROCEDURE PROC_ASOCIAR_CLIENTEOEMPRESA(DPI_CLIENTE VARCHAR2, NO_CUENTA VARCHAR2,NUM_PATENTE VARCHAR2)
IS
/*VARIABLE PARA ALMACENAR EL TOTAL DE CUENTAS ASOCIADAS A UN CLIENTE*/
TOTAL_CUENTA_ASOCIADA NUMBER;
/*SABER A CUANTAS FIRMAS ESTÁ ASOCIADA LA CUENTA DE UNA EMPRESA*/
TOTAL_EMPRESA_ASOCIADA NUMBER;
/*SI ES UNA EMPRESA VAMOS A EXTRAER ID DE LA MISMA */
/*VARIABLE PARA DETERMINAR SI EL ID DE CUENTA QUE NOS ESTÁN DANDO YA EXISTE*/
EXISTE_CUENTA NUMBER;
/*COMO AL ASOCIAR AL CLIENTE CON LA CUENTA NO SERÁ DIRECTAMENTE CON EL DPI NECESITAMOS RECUPERAR EL ID DE ESTE*/
EXTRAER_ID_CLIENTE NUMBER;
/*VARIABLE PARA SABER SI EXISTE LA PATENTE EN LA TABLA EMPRESA*/
EXISTE_PATENTE NUMBER;
/*PARA INDICARLE AL USUARIO QUE NO ESTÁ INGRESANDO UN VALOR CORRECTO O BIEN QUE NO ESTÉ CREADO EL CLIENTE EN  EL SISTEMA*/
/*VARIABLE PARA EXTRAER EL ID DE LA EMPRESAE EN BASE A SU NUMERO DE PATENTE*/
EXTRAER_ID_EMPRESA NUMBER;
DATOS_NO_VALIDOS EXCEPTION;
/*ESTA EXCEPCIÓN SE LEVANTARÁ CUANDO YA EXISTEN 3 USUARIOS ASOCIADOS A UNA CUENTA, POR ENDE NO PERMITIRÁ LA INSERCIÓN 
DE OTRO CLIENTE A ASOCIAR*/
MAXIMO_CUENTAS_ASOCIADAS EXCEPTION;
/*VARIALE PARA CAPTURAR LA EXCEPCION CUANDO NO EXISTA EL NUMERO DE PATENTE*/
NO_EXISTE_PATENTE EXCEPTION;

BEGIN
    /*VAMOS A USAR LA FUNCION PARA CONTAR A CUANTAS CUENTAS ASOCIADO UN CLIENTE*/
    SELECT FUNCT_CANTIDAD_FIRMAS_CUENTA(DPI_CLIENTE) INTO TOTAL_CUENTA_ASOCIADA FROM DUAL;
    /*VERIFICO SI LA CUENTA EXISTE, QUIZÁ ES INNECESARIO, PERO VALE LA PENA HACER EL CÁLCULO*/
    SELECT FUNCT_EXISTE_CUENTA(NO_CUENTA) INTO EXISTE_CUENTA FROM DUAL;
    /*EXTRAEMOS EL ID DEL CLIENTE PRA PODERLO ASOCIAR CON LA CUENTA*/
        SELECT FUNCT_OBTENERID_CLIENTE(DPI_CLIENTE) INTO EXTRAER_ID_CLIENTE FROM DUAL;
    /*SI EL TOTAL DE CUENTAS ES MAYOR A CERO Y MENOR A TRES, ADEMAS SI LA CUENTA EXISTE Y SI NO MANDAN NUMERO DE PATENTE, PROCEDEMOS A ASOCIAR EL CLIENTE CON LA CUENTA*/
    IF(TOTAL_CUENTA_ASOCIADA>0 AND TOTAL_CUENTA_ASOCIADA<3 AND EXISTE_CUENTA=1 AND NUM_PATENTE IS NULL) THEN
        /*EN ESTE IF VAMOS A METER LA ASOCIACION DE UNA CUENTA COMUN UY CORRIENTE CON UN CLIENTE CON OTRO CLIENTE*/
        /*AL VALIDAR LO ANTERIOR, YA PODEMOS INSERTAR, PERO NECITAMOS EL ID DEL CLIENTE PARA ESO, POR TANTO
        VAMOS A USAR LA FUNCION QUE NOS PERMITE ESO */
        INSERT INTO CLIENTE_ASOCIADO_CUENTA VALUES(EXTRAER_ID_CLIENTE,NO_CUENTA,NULL);
      
    ELSIF(TOTAL_CUENTA_ASOCIADA=3) THEN
        RAISE MAXIMO_CUENTAS_ASOCIADAS;
    
    /*SI LA CUENTA YA EXISTE, TIENE MENOS DE TRES FIRMAS ASOCIADAS Y SI EL NUMERO DE PATENTE NO ES NULO, ESTO NOS INDICARÁ QUE EL CLIENTE
    SE ASOCIARÁ  SU FIRMA CON LA CUENTA DE UNA EMPRESA*/
    ELSIF(TOTAL_CUENTA_ASOCIADA>0 AND TOTAL_CUENTA_ASOCIADA<3 AND EXISTE_CUENTA=1 AND NUM_PATENTE IS NOT NULL) THEN
        /*VERIFICAMOS SI EXISTE EL NUMERO DE PATENTE, ES DECIR, SI ESTÁ ASOCIADO A ALGUNA EMPREESA*/
        SELECT FUNCT_ASOCIAR_PATENTE(NUM_PATENTE) INTO EXISTE_PATENTE FROM DUAL; 
        /*SI EXISTE EL NUMERO DE PATENTE LA FUNCION DEVOLVERA 1 Y SINO UN CERO PARA QUE MANEJEMOS LA EXCEPCION*/
        IF(EXISTE_PATENTE=1) THEN
            SELECT DEVOLVER_ID_EMPRESA(NUM_PATENTE) INTO EXTRAER_ID_EMPRESA FROM DUAL;
            INSERT INTO CLIENTE_ASOCIADO_CUENTA VALUES(EXTRAER_ID_CLIENTE,NO_CUENTA,EXTRAER_ID_EMPRESA);

        ELSE
            RAISE NO_EXISTE_PATENTE;

        END IF;
    /*SI DEVUELVE 0 QUIERE DECIR QUE EL NUMERO DE DPI ESTÁ MAL, O EL NUMERO DE CUENTA O NO EXISTE UN CLIENTE CREADO CON ESE DPI
    O NUMERO DE CUENTA*/
    
    ELSE
        RAISE DATOS_NO_VALIDOS;
    END IF;
EXCEPTION
    WHEN NO_EXISTE_PATENTE THEN
        DBMS_OUTPUT.PUT_LINE('EL NUMERO DE PATENTE INGRESADO NO ESTÁ REGISTRADO EN NINGUNA EMPRESA, CORROBORE');
    WHEN MAXIMO_CUENTAS_ASOCIADAS THEN
         DBMS_OUTPUT.PUT_LINE('UNA CUENTA NO PUEDE ESTAR ASOCIADA A MAS DE TRES FIRMAS');
    WHEN DATOS_NO_VALIDOS THEN
         DBMS_OUTPUT.PUT_LINE('LOS DATOS INGRESADOS NO SON CORRECTOS, VERIFIQUE SI EL CLIENTE YA ESTA CREADO EN EL SISTEMA');
    WHEN DUP_VAL_ON_INDEX THEN
         DBMS_OUTPUT.PUT_LINE('EL CLIENTE YA ESTA ASOCIADO CON LA CUENTA');
    WHEN TOO_MANY_ROWS THEN
         DBMS_OUTPUT.PUT_LINE('ESTÁ DEVOLVIENDO MAS DE UN DATO, CONTACTE AL DBA'); 
    WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE(SQLCODE|| '     ERROR EN FUNCION DE ASOCIAR CUENTA     '|| SQLERRM); 
END PROC_ASOCIAR_CLIENTEOEMPRESA;
/



/*----------------------------------------------------------------------------------------------------------------------------*/
    /*STORED PROCEDURE Y FUNCION PARA LA ACTUALIZACION DE UNA ASOCIACIÓN DE CUENTA*/
/*-----------------------------------------------------------------------------------------------------------------------------*/
/*VAMOS A CREAR UNA FUNCION QUE NOS VAYA A VERIFICAR ANTES SI LOS CLIENTES 
EN ESTE CASO EL VIEJO Y EL NUEVO, EEFECTIVAMENTE EXISTEN EN LA TABLA CLIENTE, PUES PUEDE PASAR QUE NOS
 DEN UN DPI INCORRECTO*/

/*PARA QUE SE PUEDA HACER EL MATCH AMBOS DEBEN EXISTIR, SI ES ASÍ MANDAMOS UN 1 SINO UN 0 SI ALGUNO DE LOST
DOS NO EXISTE O FUE INGRESADO MAL EL NUMERO*/
CREATE OR REPLACE FUNCTION FUNCT_EXISTEN_CLIENTES(DPIUNO VARCHAR2, DPIDOS VARCHAR2)
RETURN NUMBER
IS
/*VARIABLES PARA OBTENER EL VALOR SI UN CLIENTE EXISTE DENTRO DE NUESTROS REGISTROS, DEVOLVERÁ 1 SI SI Y 0 SINO*/
EXISTE_CLIENTE_NUEVO NUMBER;
EXISTE_CLIENTE_VIEJO NUMBER;
BEGIN
    SELECT FUNCT_EXISTE_CLIENTE(DPIUNO) INTO EXISTE_CLIENTE_NUEVO FROM CLIENTE
    WHERE CLIENTE.ID_ESTATUS_CLIENTE=(SELECT ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE WHERE NOMBRE='ACTIVO')
    AND DPIUNO=CLIENTE.DPI;

    /*PUEDE SER TAMBIEN QUE UN USUARIO VIEJO SE ENCUENTRE INACTIVO Y POR ESO LO VAYAN A CAMBIAR, UNO BLOQUEADO NO
    LO VAMOS A PERMITIR POR REGLAS PROPIAS DEL NEGOCIO*/
    SELECT FUNCT_EXISTE_CLIENTE(DPIDOS) INTO EXISTE_CLIENTE_VIEJO FROM CLIENTE
    WHERE CLIENTE.ID_ESTATUS_CLIENTE=(SELECT ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE WHERE NOMBRE='ACTIVO')
    OR CLIENTE.ID_ESTATUS_CLIENTE=(SELECT ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE WHERE NOMBRE='INACTIVO')
    AND DPIDOS=CLIENTE.DPI;

    /*SI AMBOS EXISTEN*/
    IF(EXISTE_CLIENTE_NUEVO=1 AND EXISTE_CLIENTE_VIEJO=1) THEN
        RETURN 1;
    ELSE
        RETURN 0;
    END IF;

END;


/*STORED PROCEDURE PARA ACTUALIZAR EL ASOCIADO DE UAN CUENTA*/
CREATE OR REPLACE PROCEDURE PROC_ACTUALIZAR_ASOC_CUENTA(DPI_CLIENTE_NUEVO VARCHAR2, NO_CUENTA VARCHAR2,NUM_PATENTE VARCHAR2, DPI_CLIENTE_VIEJO VARCHAR2)
IS
/*VARIABLE PARA ALMACENAR EL TOTAL DE CUENTAS ASOCIADAS A UN CLIENTE*/
TOTAL_CUENTA_ASOCIADA NUMBER;
/*SABER A CUANTAS FIRMAS ESTÁ ASOCIADA LA CUENTA DE UNA EMPRESA*/
TOTAL_EMPRESA_ASOCIADA NUMBER;
/*VARIABLE PARA CAPTURAR SI LOS DPIS EXISTEN EN LA TABLA DE CLIENTES, SINO QUIERE DECIR QUE NO ESTÁN REGISTRADOS
Y EN CONSECUENCIA SI UNO DE ELLOS NO LO ESTÁ, ES IMPOSIBLE ACTUALIZAR NUESTRAS CUENTAS ASOCIADAS*/
EXISTEN_CLIENTES NUMBER;
/*SI ES UNA EMPRESA VAMOS A EXTRAER ID DE LA MISMA */
/*VARIABLE PARA DETERMINAR SI EL ID DE CUENTA QUE NOS ESTÁN DANDO YA EXISTE*/
EXISTE_CUENTA NUMBER;
/*COMO AL ASOCIAR AL CLIENTE CON LA CUENTA NO SERÁ DIRECTAMENTE CON EL DPI NECESITAMOS RECUPERAR EL ID DE ESTE*/
EXTRAER_ID_CLIENTE NUMBER;
/*VARIABLE PARA SABER SI EXISTE LA PATENTE EN LA TABLA EMPRESA*/
EXISTE_PATENTE NUMBER;
/*PARA INDICARLE AL USUARIO QUE NO ESTÁ INGRESANDO UN VALOR CORRECTO O BIEN QUE NO ESTÉ CREADO EL CLIENTE EN  EL SISTEMA*/
DATOS_NO_VALIDOS EXCEPTION;
/*ESTA EXCEPCIÓN SE LEVANTARÁ CUANDO YA EXISTEN 3 USUARIOS ASOCIADOS A UNA CUENTA, POR ENDE NO PERMITIRÁ LA INSERCIÓN 
DE OTRO CLIENTE A ASOCIAR*/
MAXIMO_CUENTAS_ASOCIADAS EXCEPTION;
/*EXCEPCION PROPIA PARA INDICAR QUE LOS NUMEROS DE DPI INGRESADOS NO ESTAN ASOCIADOS A NINGUNA CUENTA*/
DPIS_INCORRECTOS EXCEPTION;
/*VARIALE PARA CAPTURAR LA EXCEPCION CUANDO NO EXISTA EL NUMERO DE PATENTE*/
NO_EXISTE_DATA EXCEPTION;

BEGIN
    /*ANTES DE TODO ESTO VAMOS A VALIDAR QUE LOS CLIENTES ESTÉN REGISTRADOS TANTO EL ANTIGUO COMO EL NUEVO*/
     SELECT FUNCT_EXISTEN_CLIENTES(DPI_CLIENTE_NUEVO, DPI_CLIENTE_VIEJO) INTO EXISTEN_CLIENTES FROM DUAL;
    /*SI LOS DPIS SI ESTAN REGISTRADOS EN NUESTRA TABLA CLIENTES, OBVIAMENTE SE PUEDE VALIDAR TAMBIEN SI ESTÁN ACTIVOS O INACTIVOS
    PERO ESTO SE PUEDE HACER DESPUÉS*/
    IF(EXISTEN_CLIENTES=1) THEN

        /*VAMOS A USAR LA FUNCION PARA CONTAR A CUANTAS CUENTAS ASOCIADO UN CLIENTE*/
        SELECT FUNCT_CANTIDAD_FIRMAS_CUENTA(DPI_CLIENTE_NUEVO) INTO TOTAL_CUENTA_ASOCIADA FROM DUAL;
        /*VERIFICO SI LA CUENTA EXISTE, QUIZÁ ES INNECESARIO, PERO VALE LA PENA HACER EL CÁLCULO*/
        SELECT FUNCT_EXISTE_CUENTA(NO_CUENTA) INTO EXISTE_CUENTA FROM DUAL;
        /*EXTRAEMOS EL ID DEL CLIENTE PRA PODERLO ASOCIAR CON LA CUENTA*/
        SELECT FUNCT_OBTENERID_CLIENTE(DPI_CLIENTE_NUEVO) INTO EXTRAER_ID_CLIENTE FROM DUAL;
        /*SI EL TOTAL DE CUENTAS ES MAYOR A CERO Y MENOR A TRES, ADEMAS SI LA CUENTA EXISTE Y SI NO MANDAN NUMERO DE PATENTE, PROCEDEMOS A ASOCIAR EL CLIENTE CON LA CUENTA*/
        IF(TOTAL_CUENTA_ASOCIADA>0 AND TOTAL_CUENTA_ASOCIADA<3 AND EXISTE_CUENTA=1 AND NUM_PATENTE IS NULL) THEN
            /*EN ESTE IF VAMOS A METER LA ASOCIACION DE UNA CUENTA COMUN UY CORRIENTE CON UN CLIENTE CON OTRO CLIENTE*/
            /*AL VALIDAR LO ANTERIOR, YA PODEMOS INSERTAR, PERO NECITAMOS EL ID DEL CLIENTE PARA ESO, POR TANTO
            VAMOS A USAR LA FUNCION QUE NOS PERMITE ESO */
            UPDATE CLIENTE_ASOCIADO_CUENTA SET ID_CLIENTE=DPI_CLIENTE_NUEVO WHERE ID_CLIENTE=DPI_CLIENTE_VIEJO AND ID_CUENTA=NO_CUENTA;
        
        /*SI LA CUENTA TIENE MAS DE TRES CUENTAS ASOCIADAS (COSA QUE NO PASARA, PUES LO VALIDAMOS EN LA INSERCION DE LA ASOCIOÓN
        SE PUEDE LLEGAR A LEVANTAR LA EXCEPCION*/
        ELSIF(TOTAL_CUENTA_ASOCIADA=3) THEN
            RAISE MAXIMO_CUENTAS_ASOCIADAS;
        
        /*SI LA CUENTA YA EXISTE, TIENE MENOS DE TRES FIRMAS ASOCIADAS Y SI EL NUMERO DE PATENTE NO ES NULO, ESTO NOS INDICARÁ QUE EL CLIENTE
        SE ASOCIARÁ  SU FIRMA CON LA CUENTA DE UNA EMPRESA*/
        ELSIF(TOTAL_CUENTA_ASOCIADA>0 AND TOTAL_CUENTA_ASOCIADA<3 AND EXISTE_CUENTA=1 AND NUM_PATENTE IS NOT NULL) THEN
            /*VERIFICAMOS SI EXISTE EL NUMERO DE PATENTE, ES DECIR, SI ESTÁ ASOCIADO A ALGUNA EMPREESA*/
            SELECT FUNCT_ASOCIAR_PATENTE(NUM_PATENTE) INTO EXISTE_PATENTE FROM EMPRESA; 
            /*SI EXISTE EL NUMERO DE PATENTE LA FUNCION DEVOLVERA 1 Y SINO UN CERO PARA QUE MANEJEMOS LA EXCEPCION*/
            IF(EXISTE_PATENTE=1) THEN
               UPDATE CLIENTE_ASOCIADO_CUENTA SET ID_CLIENTE=DPI_CLIENTE_NUEVO WHERE ID_CLIENTE=DPI_CLIENTE_VIEJO AND ID_CUENTA=NO_CUENTA;

            ELSE
                RAISE NO_EXISTE_DATA;

            END IF;
        /*SI DEVUELVE 0 QUIERE DECIR QUE EL NUMERO DE DPI ESTÁ MAL, O EL NUMERO DE CUENTA O NO EXISTE UN CLIENTE CREADO CON ESE DPI
        O NUMERO DE CUENTA*/
        
        ELSE
            RAISE DATOS_NO_VALIDOS;
        END IF;

    ELSE
        /*SI ALGUNO DE LOS DEPIS FUE MAL INGRESADO VAMOS A MANEJAR ESTA EXPCEIÓN */
       RAISE DPIS_INCORRECTOS; 
    END IF;
EXCEPTION
    WHEN DPIS_INCORRECTOS THEN
        DBMS_OUTPUT.PUT_LINE('REVISE LOS NUMEROS DE DPI, ALGUNO NO ESTÁ REGISTRADO, SINO EXISTE EL CLIENTE, INDIQUELE QUE DEBE PASAR CON SERVICIO
        AL CLIENTE PARA QUE LE CREE UN PERFIL Y POR ENDE UNA CUENTA');
    WHEN NO_EXISTE_DATA THEN
        DBMS_OUTPUT.PUT_LINE('DATOS INCORRECTOS, VERIFIQUE QUE LOS NUMEROS DE DPI SEAN CORRECTOS O DE LA PATENTE, SINO ESTO QUIERE DECIR QUE NO EXISTE ALGUNA CUENTA
        CON LOS DATOS PROPORCIONADOS');
    WHEN MAXIMO_CUENTAS_ASOCIADAS THEN
         DBMS_OUTPUT.PUT_LINE('UNA CUENTA NO PUEDE ESTAR ASOCIADA A MAS DE TRES FIRMAS');
    WHEN DATOS_NO_VALIDOS THEN
         DBMS_OUTPUT.PUT_LINE('LOS DATOS INGRESADOS NO SON CORRECTOS, VERIFIQUE SI EL CLIENTE YA ESTA CREADO EN EL SISTEMA');
    WHEN DUP_VAL_ON_INDEX THEN
         DBMS_OUTPUT.PUT_LINE('EL CLIENTE YA ESTA ASOCIADO CON LA CUENTA');
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('DATOS INCOCRRECTOS, NO EXISTE EL CLIENTE O LA PATENTE, REVISE');
    WHEN TOO_MANY_ROWS THEN
         DBMS_OUTPUT.PUT_LINE('ESTÁ DEVOLVIENDO MAS DE UN DATO, CONTACTE AL DBA'); 
    WHEN OTHERS THEN
         DBMS_OUTPUT.PUT_LINE(SQLCODE|| '     ERROR EN FUNCION DE ASOCIAR CUENTA     '|| SQLERRM); 
END PROC_ACTUALIZAR_ASOC_CUENTA;
/




/**------------------------------------------------------------------------------------/
/----------*TRIGGERS PARA LA CREACION DE LOG EN BITACORA CLIENTE_ASOCIADO_CUENTA*/
CREATE OR REPLACE TRIGGER AIUD_TBL_CL_ASOC_CUENTA
AFTER INSERT OR UPDATE OR DELETE  ON CLIENTE_ASOCIADO_CUENTA
FOR EACH ROW
DECLARE
/*VARIABLE PARA HACER UNA VALIDACIOÓN SI EL USUARIO LOEGUEADO
 EXISTE*/
EXISTE_USUARIO NUMBER:=0;
BEGIN
    /*Validamos que el usuario de la base de datos exista dentro nuestros registros en la tabla usuario*/
    SELECT ID_USUARIO INTO EXISTE_USUARIO FROM USUARIO WHERE NOMBRE_USUARIO=USER;
            IF INSERTING THEN
                INSERT INTO BITACORA_ASOC_CUENTA(FECHA_OPERACION,VALOR_ANTIGUO, VALOR_NUEVO,CAMPO_AFECTADO,ID_CLIENTE,ID_USUARIO,ID_TIPO_OPERACION)
                VALUES(SYSDATE,NULL,NULL,NULL,:NEW.ID_CLIENTE,EXISTE_USUARIO,2);
            END IF;
            IF UPDATING ('ID_CLIENTE') THEN
                INSERT INTO BITACORA_ASOC_CUENTA(FECHA_OPERACION,VALOR_ANTIGUO, VALOR_NUEVO,CAMPO_AFECTADO,ID_CLIENTE,ID_USUARIO,ID_TIPO_OPERACION)
                VALUES(SYSDATE,:OLD.ID_CLIENTE,:NEW.ID_CLIENTE,1,:NEW.ID_CLIENTE,EXISTE_USUARIO,1);
            END IF; 
              IF UPDATING ('ID_CUENTA') THEN
                INSERT INTO BITACORA_ASOC_CUENTA(FECHA_OPERACION,VALOR_ANTIGUO, VALOR_NUEVO,CAMPO_AFECTADO,ID_CLIENTE,ID_USUARIO,ID_TIPO_OPERACION)
                VALUES(SYSDATE,:OLD.ID_CUENTA,:NEW.ID_CUENTA,2,:NEW.ID_CLIENTE,EXISTE_USUARIO,1);
            END IF; 
              IF UPDATING ('ID_EMPRESA') THEN
                INSERT INTO BITACORA_ASOC_CUENTA(FECHA_OPERACION,VALOR_ANTIGUO, VALOR_NUEVO,CAMPO_AFECTADO,ID_CLIENTE,ID_USUARIO,ID_TIPO_OPERACION)
                VALUES(SYSDATE,:OLD.ID_EMPRESA,:NEW.ID_EMPRESA,3,:NEW.ID_CLIENTE,EXISTE_USUARIO,1);
            END IF; 
    EXCEPTION
    /*si por algún motivo falla alguna conversión de un número*/
    WHEN INVALID_NUMBER THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE||'  FALLÓ LA CONVERSIÓN DE:    '||SQLERRM);
    /*si el usuario quiere insertar un valor con un id de la tabla  ya  creado*/
    WHEN DUP_VAL_ON_INDEX THEN
        DBMS_OUTPUT.PUT_LINE('ESTÁ INTENTANDO REGISTRAR CON UN ID YA EXISTENTE, COMUNIQUESE CON EL DBA');
    /*si el  usuario no está registrado dentro de la base de datos*/
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('USTED NO TIENE PRIVILEGIOS O PERMISOS PARA CREAR ESTA OPERACION, CONTACTE CON EL DBA');
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:     '||'MENSAJE    '||SQLERRM);
END AIUD_TBL_CL_ASOC_CUENTA;
/
COMMIT;