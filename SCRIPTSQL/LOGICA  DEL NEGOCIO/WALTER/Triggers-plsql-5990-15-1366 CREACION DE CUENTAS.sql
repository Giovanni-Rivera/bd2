/*Los tipos de productos y código respectivos son:
1. cuenta ahorro
2. cuenta monetaria
El número de una cuenta, estará dado por los siguientes dígitos (separados por guion):
o tipo de producto
o agencia donde se apertura la cuenta
o correlativo de cuenta por cada tipo de cuenta
o el último digito esta dado aleatoriamente entre 0 y 9.

Ejemplo: Cuentas Ahorro 1 – 123 – 0000001 – 0 
(Cuenta de Ahorro, aperturada en la agencia 123, correlativo 1)

Cuentas Monetarias 2 – 044 – 00000011 – 2 (Cuenta Monetaria, aperturada en la agencia 44, correlativo 11)

Tipos de Cuentas: Ahorro y Monetaria
o Operaciones sobre las cuentas: Retiro y Deposito

vPara aperturar cualquier cuenta, es necesario presentar únicamente el DPI del cliente o la patente de comercio si es una empresa.

*/ 

/*1.- COMO SON 2 CORRELATIVOS DISTINTOS TANTO UNO PARA CUENTA DE CUENTA DE AHORRO
Y OTRO PARA CUENTA MONETARIA*/

/*1.1 CORRELATIVO PARA LA CUENTA DE AHORRO*/
CREATE SEQUENCE SEQ_CORRELATIVO_AHORRO
START WITH 1
INCREMENT BY 1;

/*1.2 CORRELATIVO PARA LA CUENTA MONETARIA*/
CREATE SEQUENCE SEQ_CORRELATIVO_MONETARIA
START WITH 1
INCREMENT BY 1;

/*1.2 CORRELATIVO PARA LA CUENTA DE UN CLIENTE PARA QUE LE PAGUEN*/
CREATE SEQUENCE SEQ_CORRELATIVO_PAGOPLANILLA
START WITH 1
INCREMENT BY 1;


/*2.- VAMOS A CREAR UNA FUNCION QUE NOS DEVUELVA UN NÚMERO
ALEATORIO ENTRE EL 0 Y EL NUEVE, PUES ESTE FORMARÁ PARTE DEL ÚLTIMO DÍGITO DE LA CUENTA*/

CREATE OR REPLACE FUNCTION FUNCT_NUMERO_ALEATORIO
RETURN NUMBER
IS
VARIABLES NUMBER;
BEGIN
   SELECT ROUND(DBMS_RANDOM.VALUE(0,9)) INTO VARIABLES FROM DUAL;
   RETURN VARIABLES;

END;

/*3.- PARA LA CREACIÓN DE CUENTA ES ÚNICAMENTE NECESARIO EL DPI DEL CLIENTE O SI ES UNA EMPRESA
LA PATENTE DE COMERCIO, ADEMÁS, NOSOTROS COMO DBA'S VAMOS A DAR ACCESO ÚNICAMENTE AL USUARIO QUE 
REALICE LA APERTURA DE LA CUENTA ÚNICAMENTE A QUE ESCOJA SI ES DE AHORRO O MONETARIA, EL MONTO A 
DEPOSITAR PARA LA APERTURA (EN EL REQUERIMIENTO DEL PROYECTO NO ESTABLECE UN MÍNIMO O MÁXIMO,
NOSOTROS NO VAMOS A DEFINIR UN MONTO PARA APERTURA DE CUENTA, PERO DEBE SER IGUAL Ò MAYOR A 0
ADEMÁS DEL ID DEL USUARIO DEL SISTEMA QUE ESTÁ CREANDO LA CUENTA, ESTO EL SOFTWARE LO HARÁ POSTERIORMENTE
DEL LADO DEL FRONTEND PARA ENVIAR AL BACKEND LOS DATOS*/

/*3.1 VAMOS A CREAR UNA FUNCIÓN PARA QUE NOS VERIFIQUE SI EL DPI DEL CLIENTE YA ESTÁ REGISTRADO EN EL SISTEMA
ES DECIR, SI PREVIAMENTE YA FUE REGISTRADO COMO CLIENTE VALGA LA REDUNDANCIA NOS DEVOLVERÁ TRUE=1 SI EXISTE Y
FALSE=0 SI NO ADEMÁS SI ESTÁ ACTIVO*/
CREATE OR REPLACE FUNCTION FUNCT_EXISTE_CLIENTE (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
/*VARIABLE PARA IR A CONTAR SI EXISTE UN CLIENTE CON ESE NUMERO DE DPI, además si está activo ESTA COLUMNA EN LA TABLA CLIENTE
SE DEFINIÓ COMO UNIQUE POR ENDE, SI EXISTE DEBE RETORNAR 1 Y SINO 0*/
CONTAR_CLIENTE NUMBER;
BEGIN
    SELECT COUNT(C.DPI) INTO CONTAR_CLIENTE FROM CLIENTE C WHERE C.DPI=DPI_CLIENTE
    AND C.ID_ESTATUS_CLIENTE=(SELECT EC.ID_ESTATUS_CLIENTE FROM ESTATUS_CLIENTE EC WHERE EC.NOMBRE='ACTIVO');
    
    IF(CONTAR_CLIENTE>0) THEN
    RETURN CONTAR_CLIENTE;
    ELSE
        RETURN 0;
    END IF; 
    EXCEPTION
    WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('NO EXISTE UN CLIENTE ASOCIADO CON EL DPI PROPORCIONADO');
    WHEN TOO_MANY_ROWS THEN
             DBMS_OUTPUT.PUT_LINE('NO PUEDE EXISTIR DOS O MAS CLIENTES CON UN MISMO DPI');
    WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'   ERROR :    '||SQLERRM);
END FUNCT_EXISTE_CLIENTE;


/*3.2 SE TIENE QUE VALIDAR QUE UN CLIENTE ESTÉ ASOCIADO ÚNICAMENTE  COMO MAXIMO A TRES FIRMAS (CUENTAS)
SE TOMARÁ EN CUENTA TAMBIÉN LA PROPIA, POR LO QUE SON ÚNICAMENTE 2 CUENTAS AJENAS TAMBIÉN QUE SE PUEDEN 
ASOCIAR*/
CREATE OR REPLACE FUNCTION FUNCT_CANTIDAD_FIRMAS_CUENTA (DPI_CLIENTE VARCHAR2)
RETURN NUMBER
IS
CORRELATIVO_CLIENTE NUMBER;
NUM_CLIENTE NUMBER;
TOTAL_FIRMAS NUMBER;
BEGIN
    /*PRIMERO VERIFICAMOS SI EL CLIENTE YA ESTÁ CREADO EN NUESTRA TABLA CON EL MISMO NOMBRE*/
    SELECT COUNT(CL.ID_CLIENTE_NUMERO) INTO NUM_CLIENTE FROM CLIENTE CL WHERE CL.DPI=DPI_CLIENTE;

    /*SI EFECTIVAMENTE EXITE, VAMOS IR A VER A LA TABLA CLIENTE_ASOCIADO_CUENTA A  CUANTAS ESTÁ ASOCIADO 
    EL CLIENTE*/
    IF(NUM_CLIENTE>0) THEN
        /*VAMOS A TRAER EL ID DEL CLIENTE*/
        SELECT CL.ID_CLIENTE_NUMERO INTO CORRELATIVO_CLIENTE FROM CLIENTE CL WHERE CL.DPI=DPI;
        /*CONTAMOS CUANTAS FIRMAS ESTÀN ASOCIADAS A ESE CLIENTE*/
        SELECT COUNT(CAC.ID_CLIENTE) INTO TOTAL_FIRMAS FROM CLIENTE_ASOCIADO_CUENTA CAC 
        WHERE CORRELATIVO_CLIENTE=CAC.ID_CLIENTE;
        /*DEVOLVEMOS LA CANTIDAD, LA VALIDACIÓN DE VER SI TIENE COMO MÁXIMO 3 FIRMAS ASOCIADAS
        SE HARÁ EN EL STORED PRODEDURE PRINCIPAL DE LA APERTURA DE LA CUENTA*/
        RETURN TOTAL_FIRMAS;
    ELSE
    /*SINO EXISTE UN CLIENTE ASOCIADO, VAMOS A DEVOLVER UN -1 PARA MANEJA LA EXPEPCION EN EL STORED 
    PROCEDURE PRINCIPAL*/
        RETURN 0;
    END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No se puede continuar con la operación, debe de registrar primero al cliente');
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    CONTACTE AL DBA');
END FUNCT_CANTIDAD_FIRMAS_CUENTA;

COMMIT;

/*3.3 TENEMOS QUE CREAR UNA FUNCION PARA CREAR EL NUMERO DE CUENTA*/
CREATE OR REPLACE FUNCTION FUNCT_CREAR_NUMERO_CUENTA(TIPO_CUENTAS NUMBER)
RETURN VARCHAR2
IS
/*VAMOS A CAPTURAR ACÁ EL NUMERO DE CUENTA FINAL QUE SE CREARÁ*/
NUMERO_FINAL VARCHAR2(30);
/*VARIABLE PARA SABER SI ES UN TIPO DE CUENTA MONETARIA O DE AHORRO*/
TIPO_CUENTA_FINAL TIPO_CUENTA.NOMBRE%TYPE;
/*VARIABLE PARA RECUPERAR A QUE AGENCIA PERTENECE EL USUARIO QUE ESTÁ CREANDO LA CUENTA*/
ID_AGENCIA_APERTURA USUARIO.ID_AGENCIA%TYPE;
/*VARIABLE PARA OBTENER DE LA FUNCION EL NUMERO ALEATORIO QUE NECESITAMOS*/
NUMERO_ALEATORIO NUMBER; 
/*VAMOS A IR A BUSCAR EL ID DEL USUARIO QUE ESTA ACTIVO, ESTO PARA SABER DE QUE AGENCIA ESTÁ HACIENDO EL MOVIMIENTO*/
ID_USUARIO_ACTIVO USUARIO.ID_USUARIO%TYPE;
/*PARA CAPTURAR DE LA FUNCION EL NUMERO ALEATORIO*/
NUMERO_RANDOM NUMBER;
/*EXCEPCION SI POR ALGUN MOTIVO (NO DEBIERA DE SUCEDER) QUE EL USUARIO ESTÉ PRETENDIENDO CREAR OTRO TIPO DE CUENTA
(APARTE DE LA MONENTARIA Y DE AHORRO)*/
NO_EXISTE_TIPO_CUENTA EXCEPTION;
/*EXCEPCIÓN PARA DETERMINAR SI UN USUARIO NO ESTÁ ACITVO O NO EXISTE EN LA TABLA USUARIO*/
USUARIO_INEXINAC EXCEPTION;

BEGIN
    /*PRIMERO DEBEMOS SABER DE DONDE SE ORIGINA LA CREACION DE LA CUENTA, ES DECIR DE LA AGENCIA, POR ENDE
    DEBEMOS RECUPERAR EL ID DEL USUARIO  PARA SABERLO*/
    SELECT U.ID_USUARIO INTO ID_USUARIO_ACTIVO FROM USUARIO U WHERE U.NOMBRE_USUARIO=(SELECT USERNAME FROM ALL_USERS WHERE USERNAME=USER)
    AND U.ESTATUS_USUARIO=(SELECT ID_ESTATUS_USUARIO FROM ESTATUS_USUARIO WHERE NOMBRE='ACTIVO');
    /*SI EXISTE EL USUARAIO, ADEMÁS SI ESTÁ ACTIVO */
    IF(ID_USUARIO_ACTIVO>0) THEN
        /*vamos en base al id recuperado del usuario que está haciendo la creación, ir a buscar el id de la agencia*/
        SELECT U.ID_AGENCIA INTO ID_AGENCIA_APERTURA FROM USUARIO U WHERE U.ID_USUARIO=ID_USUARIO_ACTIVO;
        /*LUEGO VAMOS A VERIFICAR SI LA CUENTA A CREAR ES MONETARIA O DE AHORRO, VAMOS A RECUPERAR SEGÚN EL ID SI ES DE AHORRO O MONETARIA*/
        SELECT TP.NOMBRE INTO TIPO_CUENTA_FINAL FROM TIPO_CUENTA TP WHERE TP.ID_TIPO_CUENTA=TIPO_CUENTAS;
        /*ANTES DE CREAR EL NUMERO, VAMOS A CAPTURAR EL NÚMERO ALEATORIO */
        SELECT FUNCT_NUMERO_ALEATORIO INTO NUMERO_RANDOM FROM DUAL;
        /*VALIDAMOS SI ES DE AHORRO O MONETARIA*/
        IF(TIPO_CUENTA_FINAL='DE AHORRO') THEN
            
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_AHORRO.NEXTVAL||'-'||NUMERO_RANDOM;
       
        ELSIF(TIPO_CUENTA_FINAL='MONETARIA') THEN
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_MONETARIA.NEXTVAL||'-'||NUMERO_RANDOM;
        
        /*AÚN NO SE HA CREADO, PUES SERÁ PARA LA ENTREGA FINAL, LA OPCIÓN DE CREAR CUENTAS PERO SOLO PARA PAGO DE PLANILLAS
        SE SABE Y SE ENTIENDE QUE ESTAS NO DEBEN GENERAR INTERESES*/
        ELSIF(TIPO_CUENTA_FINAL='PLANILLA') THEN
            /*INSERTAMOS VALORES*/
            NUMERO_FINAL:=TIPO_CUENTAS||'-'||ID_AGENCIA_APERTURA||'-'||SEQ_CORRELATIVO_PAGOPLANILLA.NEXTVAL||'-'||NUMERO_RANDOM;
        ELSE 
            RAISE NO_EXISTE_TIPO_CUENTA;
        END IF;
    ELSE
        /*EXCEPCION PARA INDICAR QUE EL USUARIO NO EXISTE DENTRO DE LA BASE DE DATOS O ESTÁ INACTIVO*/
        RAISE USUARIO_INEXINAC;
    END IF;
    RETURN NUMERO_FINAL;
    EXCEPTION 
    WHEN NO_EXISTE_TIPO_CUENTA THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    EL TIPO DE CUENTA ES INCORRECTO');
    WHEN USUARIO_INEXINAC THEN
         DBMS_OUTPUT.PUT_LINE('EL USUARIO CON EL QUE INTENTA CREAR LA CUENTA NO EXISTE O ESTÁ INACTIVO, NOTIFIQUE AL DBA O GERENTE');
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No se puede continuar con la operación, VERIFIQUE EL TIPO DE CUENTA');
        WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLCODE || 'ERROR: '|| SQLERRM || '    CONTACTE AL DBA');
    
END FUNCT_CREAR_NUMERO_CUENTA;


/*3.4 FUNCION QUE PERMITE RECUPERAR EL NUMERO DE AGENCIA DEL USUARIO QUE ESTÁ ACTIVO Y HARÁ LA CREACIÓN DE LA CUENTA */
 CREATE OR REPLACE FUNCTION FUNCT_BUSCAR_AGENCIA
 RETURN NUMBER
 IS
 ID_USUARIO_ACTIVO NUMBER;
 ID_AGENCIA_APERTURA NUMBER;
 BEGIN
     SELECT U.ID_USUARIO INTO ID_USUARIO_ACTIVO FROM USUARIO U
      WHERE U.NOMBRE_USUARIO=(SELECT USERNAME FROM ALL_USERS WHERE USERNAME=USER)
        AND U.ESTATUS_USUARIO=(SELECT ID_ESTATUS_USUARIO FROM ESTATUS_USUARIO WHERE NOMBRE='ACTIVO');
    IF(ID_USUARIO_ACTIVO>0) THEN
        /*vamos en base al id recuperado del usuario que está haciendo la creación, ir a buscar el id de la agencia*/
        SELECT U.ID_AGENCIA INTO ID_AGENCIA_APERTURA FROM USUARIO U WHERE U.ID_USUARIO=ID_USUARIO_ACTIVO;
         RETURN ID_AGENCIA_APERTURA;
    END IF;
   
EXCEPTION
WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('el usuario con que está intentando hacer la operación se encuentra deshabilitado');
WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:   '||SQLERRM);
 END FUNCT_BUSCAR_AGENCIA;
 
 
 
/*stored PROCEDURE para la apertura de cuenta de un cliente*/

CREATE OR REPLACE PROCEDURE PROC_APERTURA_CUENTA_CLIENTE(DPI_CLIENTE VARCHAR2, TIPO_CUENTAS NUMBER)
IS
/*VARIABLE PARA CAPTURAR EL NUMERO DE CUENTA A CREAR*/
NUMERO_CUENTA VARCHAR2(30);.
/*VARIABLE PARA VALIDAR QUE EL CLIENTE ESTÉ PREVIAMENTE CREADO EN LA TABLA CLIENTE*/
EXISTE_CLIENTE NUMBER;
/*VARIABLE PARA SABER SI EL CLIENTE TIENE ASOCIADA ALGUNA CUENTA*/
TIENE_FIRMA NUMBER;
/*SINO EXISTE VAMOS A LEVANTAR UNA EXCEPCION PROPIA*/
NO_EXISTE_CLIENTE EXCEPTION;
/*SI EL CLIENTE YA TIENE UN CUENTA ASOCIADA ES DECIR, QUE ES UNA PROPIA, SE DEBE IMPEDIR
QUE TENGA 2 CUENTAS DEL MISMO TIPO (MONETARIAS Y DE AHORRO)*/
YA_TIENE_CUENTA EXCEPTION;
/*VARIABLE PARA CAPTURA EL NUMERO DE AGENCIA DEL USUARIO QUE VA A CREAR LA CUENTA*/
NUMERO_AGENCIA NUMBER;
BEGIN
    /*USAMOS NUESTRA FUNCION PARA VALIDAR SI EXISTE EL CLIENTE, MANDAMOS COMO PARAMETRO EL DPI*/
    SELECT FUNCT_EXISTE_CLIENTE(DPI_CLIENTE) INTO EXISTE_CLIENTE FROM CLIENTE;
    /*SOLO DEBE EXISTIR UN CLIENTE POR CADA DPI (RESTRICCION A NIVEL DE COLUMNA CON LA CLÁUSULA
    UNIQUE EN EL CAMPO DEL DPI DE LA TABLA CLIENTE)*/
    IF(EXISTE_CLIENTE=1) THEN
        /*VAMOS A VER SI EL CLIENTE TIENE ASOCIADA ALGUNA CUENTA,
        POR REGLA DEL NEGOCIO PROPIA, NOSOTROS VAMOS A DEFINIR QUE PARA QUE SE LE PUEDA
        ASOCIAR UNA CUENTA, POR LO MENOS ESTE YA TIENE QUE TENER UNA PROPIA*/
        /*EN ESTA VARIABLE VAMOS A CAPTURAR UN NUMERO, SI DEVUELVE  QUIERE DECIR QUE NO TIENE
        NINGUNA CUENTA ASOCIADA Y POR ENDE SE PUEDE CREAR*/
        SELECT FUNCT_CANTIDAD_FIRMAS_CUENTA(DPI_CLIENTE) INTO TIENE_FIRMA FROM CLIENTE;
        /*SINO TIENE UNA CUENTA ASOCIADA QUIERE DECIR QUE LE DEMOS CREAR UNA*/
        IF(TIENE_FIRMA=0) THEN
            /*al ya validar lo anterior, podemos proceder a crear la cuenta del cliente, pero antes
            de todo eso vamos a invocar a nuestra función que nos permita crear el id de la cuenta según lo estipulado
            en el proyecto*/
            SELECT FUNCT_CREAR_NUMERO_CUENTA(TIPO_CUENTAS) INTO NUMERO_CUENTA FROM TIPO_CUENTA;
            /*VAMOS A ABSTRAER EL NUMERO DEL USUARIO QUE ESTÁ ACTIVO HACIENDO LA INSERCIÓN DE LA CUENTA*/
            SELECT FUNCT_BUSCAR_AGENCIA INTO NUMERO_AGENCIA FROM USUARIO;
        /*CUANDO SE CREA UNA CUENTA EL SALDO DEBE DE ESTAR EN 0 TANTO DEL SALDO EN RESERVA COMO EL DEL MONTO DISPONIBLE*/
        INSERT INTO CUENTA (ID_CUENTA,SALDO_EN_RESERVA, MONTO_DISPONIBLE, FECHA_CREACION, ID_ESTATUS, ID_TIPO, ID_AGENCIA_APERTURA);
        VALUES(NUMERO_CUENTA,0,0,SYSDATE,1,TIPO_CUENTAS,NUMERO_AGENCIA);
        ELSE
            RAISE YA_TIENE_CUENTA;
        END IF;
    ELSE
        RAISE NO_EXISTE_CLIENTE;
    END IF;
EXCEPTION
    WHEN YA_TIENE_FIRMA THEN
     DBMS_OUTPUT.PUT_LINE(' EL USUARIO YA TIENE UNA CUENTA, CONSULTE EN EL SISTEMA');
    WHEN NO_EXISTE_CLIENTE THEN
    DBMS_OUTPUT.PUT_LINE('NO EXISTE EL DPI DEL CLIENTE, FAVOR DE REVISAR QUE ESTÉ CORRECTO O QUE YA SE LE HAYA CREADO');
    WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE(' FAVOR DE REVISAR LOS DATOS INGRESADOS, PUES NO ESTÁN REGISTRADOS (CLIENTE)');
    WHEN TOO_MANY_ROWS THEN
    DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA');
    WHEN OTHERS THEN
     DBMS_OUTPUT.PUT_LINE(SQLCODE||'    ERROR:    '||SQLERRM|| 'CONTACTAR AL DBA');
    
END PROC_APERTURA_CUENTA_CLIENTE;
















/*NO_PATENTE ES EL CAMPO PARA SABER SI UNA EMPRESA YA ESTÀ REGISTRADA, */

CREATE OR REPLACE PROCEDURE PROCEDURE PROC_CREAR_CUENTA(ID_USUARIO NUMBER, TIPO_CUENTA NUMBER, DPI_CLIENTE VARCHAR2, NO_PATENTE NUMBER)
IS
/**/
BEGIN

    /*ANTES DE OPERAR HAY QUE VER SI ES UNA EMPRESA LA QUE DESEA ABRIR LA CUENTA O UNA PERSONA PARTICULAR*/
    /*SI ES UN CLIENTE, DEBE PEDIRSE EL DPI TAMBIEN*/
    IF(DPI_CLIENTE IS NOT NULL AND NO_PATENTE IS NOT NULL) THEN
        EXEC APERTURA_CUENTA_EMPRESA();

    ELSIF (DPI_CLIENTE IS NOT NULL AND NO_PATENTE IS  NULL)
        EXEC APERTURA_CUENTA_CLIENTE();
    END IF;


END PROC_CREAR_CUENTA;